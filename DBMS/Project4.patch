From 78f79090d74d853d20da70fa10d8889d975aa113 Mon Sep 17 00:00:00 2001
From: Yicong-Huang <hyc541978023@gmail.com>
Date: Mon, 18 Nov 2019 22:14:32 -0800
Subject: [PATCH 1/1] Project 4

---
 CMakeLists.txt        |   24 +-
 README.md             |   54 +-
 cli/cli.cc            | 1921 +++++++++++++++++++++++++++++++++++++++++
 cli/cli.h             |  164 ++++
 cli/cli_example_01.cc |   56 ++
 cli/cli_example_02.cc |   52 ++
 cli/cli_example_03.cc |   60 ++
 cli/cli_example_04.cc |   57 ++
 cli/cli_example_05.cc |   68 ++
 cli/cli_example_06.cc |   62 ++
 cli/cli_example_07.cc |   64 ++
 cli/cli_example_08.cc |   62 ++
 cli/cli_example_09.cc |   68 ++
 cli/cli_example_10.cc |   64 ++
 cli/cli_example_11.cc |   50 ++
 cli/cli_example_12.cc |   58 ++
 cli/makefile          |   60 ++
 cli/start.cc          |   44 +
 data/ages_90          |   90 ++
 data/employee_5       |    5 +
 data/employee_50      |   50 ++
 data/salary_5         |    5 +
 makefile.inc          |    8 +-
 project4_report.txt   |   41 +
 qe/makefile           |   61 ++
 qe/qe.cc              |    7 +
 qe/qe.h               |  275 ++++++
 qe/qe_test_util.h     | 1119 ++++++++++++++++++++++++
 qe/qetest_01.cc       |   60 ++
 qe/qetest_02.cc       |   51 ++
 qe/qetest_03.cc       |  114 +++
 qe/qetest_04.cc       |  125 +++
 qe/qetest_05.cc       |  113 +++
 qe/qetest_06.cc       |   92 ++
 qe/qetest_07.cc       |  132 +++
 qe/qetest_08.cc       |  154 ++++
 qe/qetest_09.cc       |  132 +++
 qe/qetest_10.cc       |  150 ++++
 qe/qetest_11.cc       |  162 ++++
 qe/qetest_12.cc       |  142 +++
 qe/qetest_13.cc       |   60 ++
 qe/qetest_14.cc       |   58 ++
 qe/qetest_15.cc       |   84 ++
 qe/qetest_16.cc       |   74 ++
 qe/qetest_p00.cc      |  127 +++
 qe/qetest_p01.cc      |  113 +++
 qe/qetest_p02.cc      |  133 +++
 qe/qetest_p03.cc      |  116 +++
 qe/qetest_p04.cc      |  129 +++
 qe/qetest_p05.cc      |  128 +++
 qe/qetest_p06.cc      |  129 +++
 qe/qetest_p07.cc      |  137 +++
 qe/qetest_p08.cc      |  161 ++++
 qe/qetest_p09.cc      |   79 ++
 qe/qetest_p10.cc      |   79 ++
 qe/qetest_p11.cc      |   99 +++
 qe/qetest_p12.cc      |   93 ++
 rm/makefile           |   70 +-
 rm/rm.cc              |   17 +
 rm/rm.h               |   27 +-
 60 files changed, 7919 insertions(+), 70 deletions(-)
 create mode 100755 cli/cli.cc
 create mode 100755 cli/cli.h
 create mode 100755 cli/cli_example_01.cc
 create mode 100755 cli/cli_example_02.cc
 create mode 100755 cli/cli_example_03.cc
 create mode 100755 cli/cli_example_04.cc
 create mode 100755 cli/cli_example_05.cc
 create mode 100755 cli/cli_example_06.cc
 create mode 100755 cli/cli_example_07.cc
 create mode 100755 cli/cli_example_08.cc
 create mode 100755 cli/cli_example_09.cc
 create mode 100755 cli/cli_example_10.cc
 create mode 100755 cli/cli_example_11.cc
 create mode 100755 cli/cli_example_12.cc
 create mode 100755 cli/makefile
 create mode 100755 cli/start.cc
 create mode 100755 data/ages_90
 create mode 100755 data/employee_5
 create mode 100755 data/employee_50
 create mode 100755 data/salary_5
 create mode 100755 project4_report.txt
 create mode 100755 qe/makefile
 create mode 100755 qe/qe.cc
 create mode 100755 qe/qe.h
 create mode 100755 qe/qe_test_util.h
 create mode 100755 qe/qetest_01.cc
 create mode 100755 qe/qetest_02.cc
 create mode 100755 qe/qetest_03.cc
 create mode 100755 qe/qetest_04.cc
 create mode 100755 qe/qetest_05.cc
 create mode 100755 qe/qetest_06.cc
 create mode 100755 qe/qetest_07.cc
 create mode 100755 qe/qetest_08.cc
 create mode 100755 qe/qetest_09.cc
 create mode 100755 qe/qetest_10.cc
 create mode 100755 qe/qetest_11.cc
 create mode 100755 qe/qetest_12.cc
 create mode 100755 qe/qetest_13.cc
 create mode 100755 qe/qetest_14.cc
 create mode 100755 qe/qetest_15.cc
 create mode 100755 qe/qetest_16.cc
 create mode 100755 qe/qetest_p00.cc
 create mode 100755 qe/qetest_p01.cc
 create mode 100755 qe/qetest_p02.cc
 create mode 100755 qe/qetest_p03.cc
 create mode 100755 qe/qetest_p04.cc
 create mode 100755 qe/qetest_p05.cc
 create mode 100755 qe/qetest_p06.cc
 create mode 100755 qe/qetest_p07.cc
 create mode 100755 qe/qetest_p08.cc
 create mode 100755 qe/qetest_p09.cc
 create mode 100755 qe/qetest_p10.cc
 create mode 100755 qe/qetest_p11.cc
 create mode 100755 qe/qetest_p12.cc

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 7158b8f..3c79cc4 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -4,15 +4,19 @@ project(cs222_fall19)
 set(CMAKE_CXX_STANDARD 11)
 
 add_custom_target(clean-all COMMAND rm Index* Indices* left* right* large* group* *out Tables Columns tbl_* *_file *idx)
-set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fsanitize=address -O1 -g  -fno-omit-frame-pointer")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fsanitize=address -O1 -g  -fno-omit-frame-pointer -ledit")
 if (CMAKE_BUILD_TYPE MATCHES Debug)
     add_definitions(-DDEBUG=1)
 endif ()
 
+add_definitions(-DDATABASE_FOLDER=\"../cli/\")
+
 add_library(PFM ./rbf/pfm.cc)
 add_library(RBFM ./rbf/rbfm.cc)
 add_library(RM ./rm/rm.cc ${RBFM})
 add_library(IX ./ix/ix.cc ${PFM})
+add_library(QE ./qe/qe.cc ${IX} ${RM})
+add_library(CLI ./cli/cli.cc ${QE} ${IX} ${RM})
 
 
 file(GLOB files rbf/rbftest*.cc)
@@ -34,4 +38,20 @@ foreach (file ${files})
     get_filename_component(name ${file} NAME_WE)
     add_executable(${name} ${file})
     target_link_libraries(${name} IX RM RBFM PFM)
-endforeach ()
\ No newline at end of file
+endforeach ()
+
+file(GLOB files qe/qetest_*.cc)
+foreach (file ${files})
+    get_filename_component(name ${file} NAME_WE)
+    add_executable(${name} ${file})
+    target_link_libraries(${name} QE IX RM RBFM PFM)
+endforeach ()
+
+file(GLOB files cli/cli_example_*.cc)
+foreach (file ${files})
+    get_filename_component(name ${file} NAME_WE)
+    add_executable(${name} ${file})
+    target_link_libraries(${name} CLI QE IX RM RBFM PFM)
+endforeach ()
+
+add_executable(cli_start cli/start.cc)
\ No newline at end of file
diff --git a/README.md b/README.md
index 529131c..9072cc3 100644
--- a/README.md
+++ b/README.md
@@ -6,40 +6,30 @@ If you are not using CLion and want to use command line make tool:
  - Modify the "CODEROOT" variable in makefile.inc to point to the root
   of your code base if you can't compile the code.
  
- - Implement the Index Manager (IX):
+- Implement the extension of Relation Manager (RM) to coordinate data files and the associated indices of the data files.
 
-   Go to folder "ix" and test in the following order:
+- Also, implement Query Engine (QE)
 
-   ```
+   Go to folder "qe" and type in:
+
+    make clean
+    make
+    ./qetest_01
+
+   The program should work. But it does nothing until you implement the extension of RM and QE.
+
+- If you want to try CLI:
+
+   Go to folder "cli" and type in:
+   
    make clean
-   make      
-   ./ixtest_01  
-   ./ixtest_02
-   ./ixtest_03
-   ./ixtest_04
-   ./ixtest_05
-   ./ixtest_06
-   ./ixtest_07
-   ./ixtest_08
-   ./ixtest_09
-   ./ixtest_10
-   ./ixtest_11
-   ./ixtest_12
-   ./ixtest_13
-   ./ixtest_14
-   ./ixtest_15
-   ./ixtest_extra_01
-   ./ixtest_extra_02   
-   ./ixtest_p1  
-   ./ixtest_p2
-   ./ixtest_p3
-   ./ixtest_p4
-   ./ixtest_p5
-   ./ixtest_p6    
-   ./ixtest_pe_01
-   ./ixtest_pe_02
+   make
+   ./cli_example_01
+   
+   or
+   
+   ./start
    
-   ```
+   The program should work. But you need to implement the extension of RM and QE to run this program properly. Note that examples in the cli directory are provided for your convenience. These examples are not the public test cases.
 
-   The program should run. But initially it will generates an error. You are supposed to
-   implement the API of the rest of the methods in ix.h as explained in the project description.
\ No newline at end of file
+- By default you should not change those classes defined in rm/rm.h and qe/qe.h. If you think some changes are really necessary, please contact us first.
\ No newline at end of file
diff --git a/cli/cli.cc b/cli/cli.cc
new file mode 100755
index 0000000..a1c992a
--- /dev/null
+++ b/cli/cli.cc
@@ -0,0 +1,1921 @@
+#include "cli.h"
+#include "../rm/rm_test_util.h"
+
+#include <readline/readline.h>
+#include <readline/history.h>
+#include <fstream>
+
+// Command parsing delimiters
+// TODO: update delimiters later
+#define DELIMITERS " ,()\""
+
+// CVS file read delimiters
+#define CVS_DELIMITERS ","
+#define CLI_TABLES "cli_tables"
+#define CLI_COLUMNS "cli_columns"
+#define CLI_INDEXES "cli_indexes"
+#define COLUMNS_TABLE_RECORD_MAX_LENGTH 150   // It is actually 112
+#define DIVISOR "  |  "
+#define DIVISOR_LENGTH 5
+#define EXIT_CODE -99
+
+// DATABASE_FOLDER is given by makefile.inc file.
+// If your compiler complains about DATABASE_FOLDER, explicitly define DATABASE_FOLDER here
+// #define DATABASE_FOLDER "~/Users/yourpath..."
+
+CLI *CLI::_cli = 0;
+
+CLI *CLI::Instance() {
+    if (!_cli)
+        _cli = new CLI();
+
+    return _cli;
+}
+
+CLI::CLI() {
+}
+
+CLI::~CLI() {
+}
+
+RC CLI::start() {
+
+    // what do we want from readline?
+    using_history();
+    // auto-complete = TAB
+    rl_bind_key('\t', rl_complete);
+
+    char *input, shell_prompt[100];
+    cout << "************************" << endl;
+    cout << "SecSQL CLI started" << endl;
+    cout << "Enjoy!" << endl;
+    for (;;) {
+
+        // Create prompt string from user name and current working directory.
+        //snprintf(shell_prompt, sizeof(shell_prompt), "%s >>> ", getenv("USER"));
+        snprintf(shell_prompt, sizeof(shell_prompt), ">>> ");
+        // Display prompt and read input (n.b. input must be freed after use)...
+        input = readline(shell_prompt);
+
+        // check for EOF
+        if (!input)
+            break;
+        if ((this->process(string(input))) == EXIT_CODE) {
+            free(input);
+            break;
+        }
+        add_history(input);
+        // Free Input
+        free(input);
+    }
+    cout << "Goodbye :(" << endl;
+
+    return 0;
+}
+
+RC CLI::process(const string input) {
+    // convert input to char *
+    RC code = 0;
+    char *a = new char[input.size() + 1];
+    a[input.size()] = 0;
+    memcpy(a, input.c_str(), input.size());
+
+    // tokenize input
+    char *tokenizer = strtok(a, DELIMITERS);
+    if (tokenizer != NULL) {
+
+        ////////////////////////////////////////////
+        // create table <tableName> (col1=type1, col2=type2, ...)
+        // create index <columnName> on <tableName>
+        // create catalog
+        ////////////////////////////////////////////
+        if (expect(tokenizer, "create")) {
+            tokenizer = next();
+            if (tokenizer == NULL) {
+                code = error("I expect <table> or <index>");
+            } else {
+                string type = string(tokenizer);
+
+                if (type.compare("table") == 0) // if type equals table, then create table
+                    code = createTable();
+                else if (type.compare("index") == 0) // else if type equals index, then create index
+                    code = createIndex();
+                else if (type.compare("catalog") == 0) // else if type equals catalog, then create the catalog
+                    code = createCatalog();
+            }
+        }
+            ////////////////////////////////////////////
+            // add attribute <attributeName=type> to <tableName>
+            ////////////////////////////////////////////
+        else if (expect(tokenizer, "add")) {
+            tokenizer = next();
+            if (expect(tokenizer, "attribute"))
+                code = addAttribute();
+            else
+                code = error("I expect <attribute>");
+        }
+
+            ////////////////////////////////////////////
+            // drop table <tableName>
+            // drop index <columnName> on <tableName>
+            // drop attribute <attributeName> from <tableName>
+            // drop catalog
+            ////////////////////////////////////////////
+        else if (expect(tokenizer, "drop")) {
+            tokenizer = next();
+            if (expect(tokenizer, "table")) {
+                code = dropTable();
+            } else if (expect(tokenizer, "index")) {
+                code = dropIndex();
+            } else if (expect(tokenizer, "attribute")) {
+                code = dropAttribute();
+            } else if (expect(tokenizer, "catalog")) {
+                code = dropCatalog();
+            } else
+                code = error("I expect <tableName>, <indexName>, <attribute>");
+        }
+
+            ////////////////////////////////////////////
+            // load <tableName> <fileName>
+            // drop index <indexName>
+            // drop attribute <attributeName> from <tableName>
+            ////////////////////////////////////////////
+        else if (expect(tokenizer, "load")) {
+            code = load();
+        }
+
+            ////////////////////////////////////////////
+            // print <tableName>
+            // print attributes <tableName>
+            ////////////////////////////////////////////
+        else if (expect(tokenizer, "print")) {
+            tokenizer = next();
+            if (expect(tokenizer, "body") || expect(tokenizer, "attributes"))
+                code = printAttributes();
+            else if (expect(tokenizer, "index"))
+                code = printIndex();
+            else if (tokenizer != NULL)
+                code = printTable(string(tokenizer));
+            else
+                code = error("I expect <tableName>");
+        }
+
+            ///////////////////////////////////////////////////////////////
+            // insert into <tableName> tuple(attr1=val1, attr2=value2, ...)
+            ///////////////////////////////////////////////////////////////
+        else if (expect(tokenizer, "insert")) {
+            code = insertTuple();
+        }
+
+            ////////////////////////////////////////////
+            // help
+            // help <commandName>
+            ////////////////////////////////////////////
+        else if (expect(tokenizer, "help")) {
+            tokenizer = next();
+            if (tokenizer != NULL)
+                code = help(string(tokenizer));
+            else
+                code = help("all");
+        } else if (expect(tokenizer, "quit") || expect(tokenizer, "exit") ||
+                   expect(tokenizer, "q") || expect(tokenizer, "e")) {
+            code = EXIT_CODE;
+        } else if (expect(tokenizer, "history") || expect(tokenizer, "h")) {
+            code = history();
+        }
+
+            ////////////////////////////////////////////
+            // select...
+            ////////////////////////////////////////////
+        else if (expect(tokenizer, "SELECT")) {
+            Iterator *it = NULL;
+            code = run(query(it));
+            cout << endl;
+        }
+
+            ////////////////////////////////////////////
+            // Utopia...
+            ////////////////////////////////////////////
+        else if (expect(tokenizer, "make")) {
+            code = error("this is for you Sky...");
+        } else {
+            code = error("i have no idea about this command, sorry");
+        }
+    }
+    delete[] a;
+    return code;
+}
+
+// query
+Iterator *CLI::query(Iterator *previous, int code) {
+    Iterator *it = NULL;
+    if (code >= 0 || (code != -2 && isIterator(string(next()), code))) {
+        switch (code) {
+            case FILTER:
+                it = filter(previous);
+                break;
+
+            case PROJECT:
+                it = projection(previous);
+                break;
+
+            case AGG:
+                it = aggregate(previous);
+                break;
+
+            case BNL_JOIN:
+                it = blocknestedloopjoin(previous);
+                break;
+
+            case INL_JOIN:
+                it = indexnestedloopjoin(previous);
+                break;
+
+            case GH_JOIN:
+                it = gracehashjoin(previous);
+                break;
+
+            case IDX_SCAN:
+                it = createBaseScanner("IDXSCAN");
+                break;
+
+            case TBL_SCAN:
+                it = createBaseScanner(string(next()));
+                break;
+
+            case -1:
+                error("dude, be careful with what you are writing as a query");
+                break;
+        }
+    }
+    return it;
+}
+
+// Create INLJoin
+Iterator *CLI::indexnestedloopjoin(Iterator *input) {
+    char *token = next();
+    int code = -2;
+    if (isIterator(string(token), code)) {
+        input = query(input, code);
+    }
+
+    if (input == NULL) {
+        input = createBaseScanner(string(token));
+    }
+
+    // get right table
+    token = next();
+    string rightTableName = string(token);
+    token = next(); // eat WHERE
+
+    // parse the join condition
+    Condition cond;
+    if (createCondition(getTableName(input), cond, true, rightTableName) != 0)
+        error(__LINE__);
+
+    IndexScan *right = new IndexScan(rm, rightTableName, cond.rhsAttr);
+
+    // Create Join
+    INLJoin *join = new INLJoin(input, right, cond);
+
+    return join;
+}
+
+// Create Aggregate
+Iterator *CLI::aggregate(Iterator *input) {
+    char *token = next();
+    int code = -2;
+    if (isIterator(string(token), code)) {
+        input = query(input, code);
+    }
+
+    if (input == NULL) {
+        input = createBaseScanner(string(token));
+    }
+
+    token = next();
+
+    // check GROUPBY
+    bool groupby = false;
+    Attribute gAttr;
+    if (string(token) == "GROUPBY") {
+        groupby = true;
+        if (createAttribute(input, gAttr) != 0)
+            error("CLI: " + __LINE__);
+
+        token = next(); // eat GET
+    }
+
+    string operation = string(next());
+
+    AggregateOp op;
+    if (createAggregateOp(operation, op) != 0)
+        error("CLI: " + __LINE__);
+    Attribute aggAttr;
+    if (createAttribute(input, aggAttr) != 0)
+        error("CLI: " + __LINE__);
+
+    Aggregate *agg;
+    if (groupby) {
+        agg = new Aggregate(input, aggAttr, gAttr, op);
+    } else {
+        agg = new Aggregate(input, aggAttr, op);
+    }
+    return agg;
+}
+
+// Create BNLJoin
+Iterator *CLI::blocknestedloopjoin(Iterator *input) {
+    char *token = next();
+    int code = -2;
+    if (isIterator(string(token), code)) {
+        input = query(input, code);
+    }
+
+    if (input == NULL) {
+        input = createBaseScanner(string(token));
+    }
+
+    // get right table
+    token = next();
+    string rightTableName = string(token);
+    TableScan *right = new TableScan(rm, rightTableName);
+
+    token = next(); // eat WHERE
+
+    // parse the join condition
+    Condition cond;
+    if (createCondition(getTableName(input), cond, true, rightTableName) != 0)
+        error(__LINE__);
+
+    token = next(); // eat RECORDS
+    token = next(); // get the number of pages
+
+    // Create Join
+    BNLJoin *join = new BNLJoin(input, right, cond, (unsigned) atoi(string(token).c_str()));
+
+    return join;
+}
+
+// Create GHJoin
+Iterator *CLI::gracehashjoin(Iterator *input) {
+    char *token = next();
+    int code = -2;
+    if (isIterator(string(token), code)) {
+        input = query(input, code);
+    }
+
+    if (input == NULL) {
+        input = createBaseScanner(string(token));
+    }
+
+    // get right table
+    token = next();
+    string rightTableName = string(token);
+    TableScan *right = new TableScan(rm, rightTableName);
+
+    token = next(); // eat WHERE
+
+    // parse the join condition
+    Condition cond;
+    if (createCondition(getTableName(input), cond, true, rightTableName) != 0)
+        error(__LINE__);
+
+    token = next(); // eat PARTITIONS
+    token = next(); // get partitions number
+
+    // Create Join
+    GHJoin *join = new GHJoin(input, right, cond, (unsigned) atoi(string(token).c_str()));
+
+    return join;
+}
+
+// Create Filter
+Iterator *CLI::filter(Iterator *input) {
+    char *token = next();
+    int code = -2;
+    if (isIterator(string(token), code)) {
+        input = query(input, code);
+    }
+
+    if (input == NULL) {
+        input = createBaseScanner(string(token));
+    }
+
+    token = next(); // eat WHERE
+
+    // parse the filter condition
+    Condition cond;
+    if (createCondition(getTableName(input), cond) != 0)
+        error(__LINE__);
+
+    // Create Filter
+    Filter *filter = new Filter(input, cond);
+
+    return filter;
+}
+
+// Create Projector
+Iterator *CLI::projection(Iterator *input) {
+    char *token = next();
+    int code = -2;
+    if (isIterator(string(token), code))
+        input = query(input, code);
+
+    if (input == NULL)
+        input = createBaseScanner(string(token));
+
+    token = next(); // eat GET
+    token = next(); // eat [
+
+    // parse the projection attributes
+    vector<string> attrNames;
+    while (true) {
+        token = next();
+        if (string(token) == "]")
+            break;
+        attrNames.push_back(token);
+    }
+
+
+    // if we have "*", convert it to all attributes
+    if (attrNames.at(0).compare("*") == 0) {
+        vector<Attribute> attrs;
+        input->getAttributes(attrs);
+        attrNames.clear();
+        for (uint i = 0; i < attrs.size(); i++) {
+            attrNames.push_back(attrs.at(i).name);
+        }
+    } else {
+        string tableName = getTableName(input);
+        addTableNameToAttrs(tableName, attrNames);
+    }
+
+    Project *project = new Project(input, attrNames);
+    return project;
+}
+
+Iterator *CLI::createBaseScanner(const string token) {
+    // if token is "IDXSCAN" (index scanner), create index scanner
+    if (token.compare("IDXSCAN") == 0) {
+        string tableName = string(next());
+        Condition cond;
+        if (createCondition(tableName, cond) != 0)
+            error(__LINE__);
+
+        IndexScan *is = new IndexScan(rm, tableName, cond.lhsAttr);
+
+        switch (cond.op) {
+            case EQ_OP:
+                is->setIterator(cond.rhsValue.data, cond.rhsValue.data, true, true);
+                break;
+
+            case LT_OP:
+                is->setIterator(NULL, cond.rhsValue.data, true, false);
+                break;
+
+            case GT_OP:
+                is->setIterator(cond.rhsValue.data, NULL, false, true);
+                break;
+
+            case LE_OP:
+                is->setIterator(NULL, cond.rhsValue.data, true, true);
+                break;
+
+            case GE_OP:
+                is->setIterator(cond.rhsValue.data, NULL, true, true);
+                break;
+
+            case NO_OP:
+                is->setIterator(NULL, NULL, true, true);
+                break;
+
+            default:
+                break;
+        }
+
+        return is;
+    }
+    // otherwise, create create table scanner
+    return new TableScan(rm, token);
+}
+
+bool CLI::isIterator(const string token, int &code) {
+    if (expect(token, "FILTER"))
+        code = FILTER;
+    else if (expect(token, "PROJECT"))
+        code = PROJECT;
+    else if (expect(token, "BNLJOIN"))
+        code = BNL_JOIN;
+    else if (expect(token, "INLJOIN"))
+        code = INL_JOIN;
+    else if (expect(token, "GHJOIN"))
+        code = GH_JOIN;
+    else if (expect(token, "AGG"))
+        code = AGG;
+    else if (expect(token, "IDXSCAN"))
+        code = IDX_SCAN;
+    else if (expect(token, "TBLSCAN"))
+        code = TBL_SCAN;
+    else
+        return false;
+
+    return true;
+}
+
+RC CLI::run(Iterator *it) {
+    void *data = malloc(PAGE_SIZE);
+    vector<Attribute> attrs;
+    vector<string> outputBuffer;
+    it->getAttributes(attrs);
+
+    for (uint i = 0; i < attrs.size(); i++)
+        outputBuffer.push_back(attrs.at(i).name);
+
+    while (it->getNextTuple(data) != QE_EOF) {
+        if (updateOutputBuffer(outputBuffer, data, attrs) != 0)
+            return error(__LINE__);
+    }
+
+    if (printOutputBuffer(outputBuffer, attrs.size()) != 0)
+        return error(__LINE__);
+    return 0;
+}
+
+RC CLI::createProjectAttributes(const string tableName, vector<Attribute> &attrs) {
+    char *token = next();
+    Attribute attr;
+    vector<Attribute> inputAttrs;
+    getAttributesFromCatalog(tableName, inputAttrs);
+    while (expect(token, "FROM")) {
+        // get the attribute
+        if (getAttribute(string(token), inputAttrs, attr) != 0)
+            return error("given " + string(token) + " is not found in attributes");
+        attrs.push_back(attr);
+        token = next();
+    }
+    return 0;
+}
+
+RC CLI::createCondition(const string tableName, Condition &condition, const bool join, const string joinTable) {
+    // get left attribute
+    char *token = next();
+
+    string attribute = string(token);
+    // concatenate left attribute with tableName
+    condition.lhsAttr = fullyQualify(attribute, tableName);
+
+    // get operation
+    token = next();
+    if (string(token) == "=")
+        condition.op = EQ_OP;
+    else if (string(token) == "<")
+        condition.op = LT_OP;
+    else if (string(token) == ">")
+        condition.op = GT_OP;
+    else if (string(token) == "<=")
+        condition.op = LE_OP;
+    else if (string(token) == ">=")
+        condition.op = GE_OP;
+    else if (string(token) == "!=")
+        condition.op = NE_OP;
+    else if (string(token) == "NOOP") {
+        condition.op = NO_OP;
+        return 0;
+    }
+
+    if (join) {
+        condition.bRhsIsAttr = true;
+        token = next();
+        condition.rhsAttr = fullyQualify(string(token), joinTable);
+        return 0;
+    }
+
+    condition.bRhsIsAttr = false;
+
+    // get attribute from catalog
+    Attribute attr;
+    if (this->getAttribute(tableName, attribute, attr) != 0)
+        return error(__LINE__);
+
+    Value value;
+    value.type = attr.type;
+    value.data = malloc(PAGE_SIZE);
+    token = next();
+    attribute = string(token);
+
+    int num;
+    float floatNum;
+    switch (attr.type) {
+        case TypeVarChar:
+            num = attribute.size();
+            memcpy((char *) value.data, &num, sizeof(int));
+            memcpy((char *) value.data + sizeof(int), attribute.c_str(), num);
+            break;
+        case TypeInt:
+            num = atoi(string(token).c_str());
+            memcpy((char *) value.data, &num, sizeof(int));
+            break;
+        case TypeReal:
+            floatNum = atof(string(token).c_str());
+            memcpy((char *) value.data, &floatNum, sizeof(float));
+            break;
+        default:
+            return error("cli: " + __LINE__);
+    }
+    condition.rhsValue = value;
+    return 0;
+}
+
+RC CLI::createAttribute(Iterator *input, Attribute &attr) {
+    string tableName = getTableName(input);
+    string attribute = string(next());
+    attribute = fullyQualify(attribute, tableName);
+
+    vector<Attribute> attrs;
+    input->getAttributes(attrs);
+    // get attribute from catalog
+    if (getAttribute(attribute, attrs, attr) != 0)
+        return error(__LINE__);
+    return 0;
+}
+
+RC CLI::createAggregateOp(const string operation, AggregateOp &op) {
+    if (operation == "MAX")
+        op = MAX;
+    else if (operation == "MIN")
+        op = MIN;
+    else if (operation == "SUM")
+        op = SUM;
+    else if (operation == "AVG")
+        op = AVG;
+    else if (operation == "COUNT")
+        op = COUNT;
+    else {
+        return error("create aggregate op: " + __LINE__);
+    }
+    return 0;
+}
+
+string CLI::getTableName(Iterator *it) {
+    vector<Attribute> attrs;
+    it->getAttributes(attrs);
+    unsigned loc = attrs.at(0).name.find(".", 0);
+    return attrs.at(0).name.substr(0, loc);
+}
+
+// input is like tableName.attributeName
+// returns attributeName
+string CLI::getAttribute(const string input) {
+    unsigned loc = input.find(".", 0);
+    return input.substr(loc + 1, input.size() - loc);
+}
+
+string CLI::fullyQualify(const string attribute, const string tableName) {
+    unsigned loc = attribute.find(".", 0);
+    if (loc >= 0 && loc < attribute.size())
+        return attribute;
+    else
+        return tableName + "." + attribute;
+}
+
+///////////////////////////////////
+///////////////////////////////////
+///////////////////////////////////
+///////////////////////////////////
+///////////////////////////////////
+///////////////////////////////////
+// END OF QUERY ENGINE ////////////
+///////////////////////////////////
+///////////////////////////////////
+///////////////////////////////////
+///////////////////////////////////
+///////////////////////////////////
+///////////////////////////////////
+//===============================//
+
+RC CLI::createTable() {
+    char *tokenizer = next();
+    if (tokenizer == NULL) {
+        return error("I expect <name> to be created");
+    }
+    string name = string(tokenizer);
+
+    // parse columnNames and types
+    vector<Attribute> table_attrs;
+    Attribute attr;
+    while (tokenizer != NULL) {
+        // get name if there is
+        tokenizer = next();
+        if (tokenizer == NULL) {
+            break;
+        }
+        attr.name = string(tokenizer);
+
+        tokenizer = next(); // eat =
+
+        // get type
+        tokenizer = next();
+        if (tokenizer == NULL) {
+            return error("expecting type");
+        }
+        if (expect(tokenizer, "int")) {
+            attr.type = TypeInt;
+            attr.length = 4;
+        } else if (expect(tokenizer, "real")) {
+            attr.type = TypeReal;
+            attr.length = 4;
+        } else if (expect(tokenizer, "varchar")) {
+            attr.type = TypeVarChar;
+            // read length
+            tokenizer = next();
+            attr.length = atoi(tokenizer);
+        } else {
+            return error("problem in attribute type in create table: " + string(tokenizer));
+        }
+        table_attrs.push_back(attr);
+    }
+    // cout << "create table for <" << name << "> and attributes:" << endl;
+    // for (std::vector<Attribute>::iterator it = table_attrs.begin() ; it != table_attrs.end(); ++it)
+    //    std::cout << ' ' << it->length;
+    //  cout << endl;
+
+    RC ret = rm.createTable(name, table_attrs);
+    if (ret != 0)
+        return ret;
+
+    // add table to cli catalogs
+    string file_url = string(DATABASE_FOLDER) + '/' + name;
+    ret = this->addTableToCatalog(name, file_url, "heap");
+    if (ret != 0)
+        return ret;
+
+    // add attributes to cli columns table
+    for (uint i = 0; i < table_attrs.size(); i++) {
+        this->addAttributeToCatalog(table_attrs.at(i), name, i);
+    }
+
+    return 0;
+}
+
+// create index <columnName> on <tableName>
+RC CLI::createIndex() {
+    char *tokenizer = next();
+    string columnName = string(tokenizer);
+
+    tokenizer = next();
+    if (!expect(tokenizer, "on")) {
+        return error("syntax error: expecting \"on\"");
+    }
+
+    tokenizer = next();
+    string tableName = string(tokenizer);
+
+    // check if columnName, tableName is valid
+    RID rid;
+    if (this->checkAttribute(tableName, columnName, rid) == false)
+        return error("Given tableName-columnName does not exist");
+
+    if (rm.createIndex(tableName, columnName) != 0) {
+        return error("cannot create index on column(" + columnName + ") , ixManager error");
+    }
+
+    // add index to cli_indexes table
+    if (this->addIndexToCatalog(tableName, columnName) != 0)
+        return error("error in adding index to cli_indexes table");
+
+    return 0;
+}
+
+// create the system catalog
+RC CLI::createCatalog() {
+
+    if (rm.createCatalog() != 0) {
+        return error("cannot create the system catalog.");
+    }
+
+    Attribute attr;
+
+    // create cli columns table
+    vector<Attribute> column_attrs;
+    attr.name = "column_name";
+    attr.type = TypeVarChar;
+    attr.length = 30;
+    column_attrs.push_back(attr);
+
+    attr.name = "table_name";
+    attr.type = TypeVarChar;
+    attr.length = 50;
+    column_attrs.push_back(attr);
+
+    attr.name = "position";
+    attr.type = TypeInt;
+    attr.length = 4;
+    column_attrs.push_back(attr);
+
+    attr.name = "type";
+    attr.type = TypeInt;
+    attr.length = 4;
+    column_attrs.push_back(attr);
+
+    attr.name = "length";
+    attr.type = TypeInt;
+    attr.length = 4;
+    column_attrs.push_back(attr);
+
+    if (rm.createTable(CLI_COLUMNS, column_attrs) != 0)
+        return error("cannot create " + string(CLI_COLUMNS) + " table.");
+
+    // add cli catalog attributes to CLI_COLUMNS table
+    for (uint i = 0; i < column_attrs.size(); i++) {
+        this->addAttributeToCatalog(column_attrs.at(i), CLI_COLUMNS, i);
+    }
+
+    // create CLI_TABLES table
+    vector<Attribute> table_attrs;
+    attr.name = "table_name";
+    attr.type = TypeVarChar;
+    attr.length = 50;
+    table_attrs.push_back(attr);
+
+    attr.name = "file_location";
+    attr.type = TypeVarChar;
+    attr.length = 100;
+    table_attrs.push_back(attr);
+
+    attr.name = "type";
+    attr.type = TypeVarChar;
+    attr.length = 20;
+    table_attrs.push_back(attr);
+
+    if (rm.createTable(CLI_TABLES, table_attrs) != 0)
+        return error("cannot create " + string(CLI_TABLES) + " table.");
+
+    // add cli catalog attributes to cli columns table
+    for (uint i = 0; i < table_attrs.size(); i++) {
+        this->addAttributeToCatalog(table_attrs.at(i), CLI_TABLES, i);
+    }
+
+    // add cli catalog information to itself
+    string file_url = string(DATABASE_FOLDER) + '/' + CLI_COLUMNS;
+    if (this->addTableToCatalog(CLI_COLUMNS, file_url, "heap") != 0)
+        return error("cannot add " + string(CLI_COLUMNS) + " to catalog.");
+
+    file_url = string(DATABASE_FOLDER) + '/' + CLI_TABLES;
+    if (this->addTableToCatalog(CLI_TABLES, file_url, "heap") != 0)
+        return error("cannot add " + string(CLI_TABLES) + " to catalog.");
+
+    // Adding the index table attributes to the columns table
+    vector<Attribute> index_attr;
+    attr.name = "table_name";
+    attr.type = TypeVarChar;
+    attr.length = 50;
+    index_attr.push_back(attr);
+
+    attr.name = "column_name";
+    attr.length = 30;
+    attr.type = TypeVarChar;
+    index_attr.push_back(attr);
+
+    attr.name = "max_key_length";
+    attr.length = 4;
+    attr.type = TypeInt;
+    index_attr.push_back(attr);
+
+    attr.name = "is_variable_length";
+    attr.length = 4;
+    attr.type = TypeInt;
+    index_attr.push_back(attr);
+
+    if (rm.createTable(CLI_INDEXES, index_attr) != 0)
+        return error("cannot create " + string(CLI_INDEXES) + " table.");
+
+    // add cli index attributes to cli columns table
+    for (uint i = 0; i < index_attr.size(); i++) {
+        this->addAttributeToCatalog(index_attr.at(i), CLI_INDEXES, i);
+    }
+
+    // add cli catalog information to itself
+    file_url = string(DATABASE_FOLDER) + '/' + CLI_INDEXES;
+    if (this->addTableToCatalog(CLI_INDEXES, file_url, "heap") != 0)
+        return error("cannot add " + string(CLI_INDEXES) + " to catalog.");
+
+    return 0;
+}
+
+RC CLI::addAttribute() {
+    Attribute attr;
+    char *tokenizer = next(); // attributeName
+    attr.name = string(tokenizer);
+    if (tokenizer == NULL)
+        return error("I expect type for attribute");
+
+    tokenizer = next(); // eat =
+
+    tokenizer = next(); // type
+
+    if (expect(tokenizer, "int")) {
+        attr.type = TypeInt;
+        attr.length = 4;
+    } else if (expect(tokenizer, "real")) {
+        attr.type = TypeReal;
+        attr.length = 4;
+    } else if (expect(tokenizer, "varchar")) {
+        attr.type = TypeVarChar;
+        // read length
+        if (tokenizer == NULL)
+            return error("I expect length for varchar");
+        tokenizer = next();
+        attr.length = atoi(tokenizer);
+    }
+
+    tokenizer = next();
+    if (expect(tokenizer, "to") == false) {
+        return error("expect to");
+    }
+    tokenizer = next(); //tableName
+    string tableName = string(tokenizer);
+
+    // add entry to CLI_COLUMNS
+    vector<Attribute> attributes;
+    this->getAttributesFromCatalog(CLI_COLUMNS, attributes);
+
+    // Set up the iterator
+    RM_ScanIterator rmsi;
+    RID rid;
+    void *data_returned = malloc(PAGE_SIZE);
+
+    // convert attributes to vector<string>
+    vector<string> stringAttributes;
+    stringAttributes.push_back("position");
+
+    // Delete columns
+    int stringSize = tableName.size();
+    void *value = malloc(stringSize + sizeof(unsigned));
+    memcpy((char *) value, &stringSize, sizeof(unsigned));
+    memcpy((char *) value + sizeof(unsigned), tableName.c_str(), stringSize);
+
+    if (rm.scan(CLI_COLUMNS, "table_name", EQ_OP, value, stringAttributes, rmsi) != 0)
+        return -1;
+
+    int biggestPosition = 0, position = 0;
+    while (rmsi.getNextTuple(rid, data_returned) != RM_EOF) {
+        // adding +1 because of nulls-indicator
+        memcpy(&position, (char *) data_returned + 1, sizeof(int));
+        if (biggestPosition < (int) position)
+            biggestPosition = position;
+    }
+    if (this->addAttributeToCatalog(attr, tableName, biggestPosition + 1) != 0)
+        return -1;
+    rmsi.close();
+    free(value);
+    free(data_returned);
+    return rm.addAttribute(tableName, attr);
+}
+
+RC CLI::dropTable() {
+    char *tokenizer = next();
+    if (tokenizer == NULL)
+        return error("I expect <tableName> to be dropped");
+
+    string tableName = string(tokenizer);
+
+    // delete indexes from cli_indexes table if there are
+    RID rid;
+    vector<Attribute> attributes;
+    this->getAttributesFromCatalog(tableName, attributes);
+    for (uint i = 0; i < attributes.size(); i++) {
+        if (this->checkAttribute(tableName, attributes.at(i).name, rid, false)) {
+            // delete the index from cli_indexes table
+            if (rm.deleteTuple(CLI_INDEXES, rid) != 0)
+                return -1;
+        }
+    }
+
+
+
+    // Set up the iterator
+    Attribute attr;
+    RM_ScanIterator rmsi;
+    void *data_returned = malloc(PAGE_SIZE);
+
+    // convert attributes to vector<string>
+    vector<string> stringAttributes;
+    stringAttributes.push_back("table_name");
+
+    int stringSize = tableName.size();
+    void *value = malloc(stringSize + sizeof(unsigned));
+    memcpy((char *) value, &stringSize, sizeof(unsigned));
+    memcpy((char *) value + sizeof(unsigned), tableName.c_str(), stringSize);
+
+    if (rm.scan(CLI_TABLES, "table_name", EQ_OP, value, stringAttributes, rmsi) != 0)
+        return -1;
+
+    // delete tableName from CLI_TABLES
+    while (rmsi.getNextTuple(rid, data_returned) != RM_EOF) {
+        if (rm.deleteTuple(CLI_TABLES, rid) != 0)
+            return -1;
+    }
+    rmsi.close();
+    free(value);
+
+    // Delete columns from CLI_COLUMNS
+
+    stringSize = tableName.size();
+    value = malloc(stringSize + sizeof(unsigned));
+    memcpy((char *) value, &stringSize, sizeof(unsigned));
+    memcpy((char *) value + sizeof(unsigned), tableName.c_str(), stringSize);
+
+    if (rm.scan(CLI_COLUMNS, "table_name", EQ_OP, value, stringAttributes, rmsi) != 0)
+        return -1;
+
+
+    // We rely on the fact that RM_EOF is not 0.
+    // we want to return -1 when getNext tuple errors
+    RC ret = -10;
+    while ((ret = rmsi.getNextTuple(rid, data_returned)) == 0) {
+        if (rm.deleteTuple(CLI_COLUMNS, rid) != 0)
+            return -1;
+    }
+    rmsi.close();
+    free(value);
+
+    if (ret != RM_EOF)
+        return -1;
+
+    free(data_returned);
+
+    // and finally DeleteTable
+    ret = rm.deleteTable(tableName);
+    if (ret != 0)
+        return error("error in deleting table in recordManager");
+
+    return 0;
+}
+
+// drop index <columnName> on <tableName>
+RC CLI::dropIndex(const string tableName, const string columnName, bool fromCommand) {
+    string realTable;
+    string realColumn;
+    if (fromCommand == false) {
+        realTable = tableName;
+        realColumn = columnName;
+    } else {
+        // parse willDelete from command line
+        char *tokenizer = next();
+        realColumn = string(tokenizer);
+
+        tokenizer = next();
+        if (!expect(tokenizer, "on")) {
+            return error("syntax error: expecting \"on\"");
+        }
+
+        tokenizer = next();
+        realTable = string(tokenizer);
+    }
+    RC rc;
+    // check if index is there or not
+    RID rid;
+    if (!this->checkAttribute(realTable, realColumn, rid, false)) {
+        if (fromCommand)
+            return error("given " + realTable + ":" + realColumn + " index does not exist in cli_indexes");
+        else // return error but print nothing
+            return -1;
+    }
+
+    // drop the index
+    rc = rm.destroyIndex(realTable, realColumn);
+    if (rc != 0)
+        return error("error while destroying index in ixManager");
+
+    // delete the index from cli_indexes table
+    rc = rm.deleteTuple(CLI_INDEXES, rid) != 0;
+
+    return rc;
+}
+
+// drop the system catalog
+RC CLI::dropCatalog() {
+    if (rm.deleteCatalog() != 0) {
+        return error("error while deleting the system catalog.");
+    }
+
+    return 0;
+}
+
+RC CLI::dropAttribute() {
+    char *tokenizer = next(); // attributeName
+    string attrName = string(tokenizer);
+    tokenizer = next();
+    if (expect(tokenizer, "from") == false) {
+        return error("expect from");
+    }
+    tokenizer = next(); //tableName
+    string tableName = string(tokenizer);
+
+    RID rid;
+    if (!this->checkAttribute(tableName, attrName, rid)) {
+        return error("given tableName-attrName does not exist");
+    }
+    // delete entry from CLI_COLUMNS
+    RC rc = rm.deleteTuple(CLI_COLUMNS, rid) != 0;
+    if (rc != 0)
+        return rc;
+
+    // drop attribute
+    rc = rm.dropAttribute(tableName, attrName);
+    if (rc != 0)
+        return rc;
+
+    // if there is an index on dropped attribute
+    //    delete the index from cli_indexes table
+    bool hasIndex = this->checkAttribute(tableName, attrName, rid, false);
+
+    if (hasIndex) {
+        // delete the index from cli_indexes table
+        rc = rm.deleteTuple(CLI_INDEXES, rid) != 0;
+        if (rc != 0)
+            return rc;
+    }
+
+    return 0;
+}
+
+// CSV reader without escaping commas
+// should be fixed
+// reads files in data folder
+RC CLI::load() {
+    char *commandTokenizer = next();
+    if (commandTokenizer == NULL)
+        return error("I expect <tableName>");
+
+    string tableName = string(commandTokenizer);
+    commandTokenizer = next();
+    if (commandTokenizer == NULL) {
+        return error("I expect <fileName> to be loaded");
+    }
+    string fileName = string(commandTokenizer);
+
+    // get attributes from catalog
+    Attribute attr;
+    vector<Attribute> attributes;
+    this->getAttributesFromCatalog(tableName, attributes);
+    uint offset = 0, index = 0, keyIndex = 0;
+    uint length;
+    void *buffer = malloc(PAGE_SIZE);
+    void *key = malloc(PAGE_SIZE);
+    RID rid;
+
+    // find out if there is any index for tableName
+    unordered_map<int, void *> indexMap;
+    for (uint i = 0; i < attributes.size(); i++) {
+        if (this->checkAttribute(tableName, attributes.at(i).name, rid, false))
+            // add index to index-map
+            indexMap[i] = malloc(PAGE_SIZE);
+    }
+
+    // read file
+    ifstream ifs;
+    string file_url = DATABASE_FOLDER"../data/" + fileName;
+    ifs.open(file_url, ifstream::in);
+
+    if (!ifs.is_open())
+        return error("could not open file: " + file_url);
+
+    // Assume that we don't have any NULL values when loading data.
+    // Null-indicators
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attributes.size());
+    unsigned char *nullsIndicator = (unsigned char *) malloc(nullAttributesIndicatorActualSize);
+    memset(nullsIndicator, 0, nullAttributesIndicatorActualSize);
+
+    string line, token;
+    char *tokenizer;
+    while (ifs.good()) {
+        getline(ifs, line);
+        if (line.compare("") == 0)
+            continue;
+        char *a = new char[line.size() + 1];
+        a[line.size()] = 0;
+        memcpy(a, line.c_str(), line.size());
+        index = 0, offset = 0;
+
+        // Null-indicator for the fields
+        memcpy((char *) buffer + offset, nullsIndicator, nullAttributesIndicatorActualSize);
+        offset += nullAttributesIndicatorActualSize;
+
+        // tokenize input
+        tokenizer = strtok(a, CVS_DELIMITERS);
+        while (tokenizer != NULL) {
+            attr = attributes.at(index++);
+            token = string(tokenizer);
+            if (attr.type == TypeVarChar) {
+                length = token.size();
+                memcpy((char *) buffer + offset, &length, sizeof(int));
+                offset += sizeof(int);
+                memcpy((char *) buffer + offset, token.c_str(), length);
+                offset += length;
+
+                auto got = indexMap.find(keyIndex);
+                if (got != indexMap.end())
+                    memcpy((char *) indexMap[keyIndex], (char *) buffer + offset - sizeof(int) - length,
+                           sizeof(int) + length);
+            } else if (attr.type == TypeInt) {
+                int num = atoi(tokenizer);
+                memcpy((char *) buffer + offset, &num, sizeof(num));
+                offset += sizeof(num);
+
+                auto got = indexMap.find(keyIndex);
+                if (got != indexMap.end())
+                    memcpy((char *) indexMap[keyIndex], (char *) buffer + offset - sizeof(int), sizeof(int));
+            } else if (attr.type == TypeReal) {
+                float num = atof(tokenizer);
+                memcpy((char *) buffer + offset, &num, sizeof(num));
+                offset += sizeof(num);
+
+                auto got = indexMap.find(keyIndex);
+                if (got != indexMap.end())
+                    memcpy((char *) indexMap[keyIndex], (char *) buffer + offset - sizeof(float), sizeof(int));
+            }
+
+            tokenizer = strtok(NULL, CVS_DELIMITERS);
+            keyIndex += 1;
+            if (keyIndex == attributes.size())
+                keyIndex = 0;
+        }
+        if (this->insertTupleToDB(tableName, attributes, buffer, indexMap) != 0) {
+            return error("error while inserting tuple");
+        }
+
+        delete[] a;
+        // prepare tuple for addition
+        // for (std::vector<Attribute>::iterator it = attrs.begin() ; it != attrs.end(); ++it)
+        // totalLength += it->length;
+    }
+    // clear up indexMap
+    for (auto it = indexMap.begin(); it != indexMap.end(); ++it) {
+        free(it->second);
+    }
+
+    free(buffer);
+    free(key);
+    ifs.close();
+    return 0;
+}
+
+RC CLI::insertTuple() {
+    char *token = next();
+    if (!expect(token, "into"))
+        return error("expecting into" + __LINE__);
+
+    string tableName = next();
+
+    token = next(); // tuple
+    if (!expect(token, "tuple"))
+        return error("expecting tuple" + __LINE__);
+
+    // get attributes from catalog
+    Attribute attr;
+    vector<Attribute> attributes;
+    this->getAttributesFromCatalog(tableName, attributes);
+    int offset = 0, index = 0;
+    int length;
+    void *buffer = malloc(PAGE_SIZE);
+    memset(buffer, 0, PAGE_SIZE);
+    void *key = malloc(PAGE_SIZE);
+    RID rid;
+
+    // find out if there is any index for tableName
+    unordered_map<int, void *> indexMap;
+    for (uint i = 0; i < attributes.size(); i++) {
+        if (this->checkAttribute(tableName, attributes.at(i).name, rid, false))
+            // add index to index-map
+            indexMap[i] = malloc(PAGE_SIZE);
+    }
+
+    // Assume that we don't have any NULL values when inserting data.
+    // Null-indicators
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attributes.size());
+    unsigned char *nullsIndicator = (unsigned char *) malloc(nullAttributesIndicatorActualSize);
+
+    memset(nullsIndicator, 0, nullAttributesIndicatorActualSize);
+
+    // Null-indicator for the fields
+    memcpy((char *) buffer + offset, nullsIndicator, nullAttributesIndicatorActualSize);
+    offset += nullAttributesIndicatorActualSize;
+
+    // tokenize input
+    token = next();
+    while (token != NULL) {
+        attr = attributes[index];
+        if (attributes.at(index).name.compare(string(token)) != 0)
+            return error("this table does not have this attribute!");
+        token = next(); // eat =
+        token = next();
+        if (attr.type == TypeVarChar) {
+            string varChar = string(token);
+            length = varChar.size();
+            memcpy((char *) buffer + offset, &length, sizeof(int));
+            offset += sizeof(int);
+            memcpy((char *) buffer + offset, varChar.c_str(), length);
+            offset += length;
+
+            auto got = indexMap.find(index);
+            if (got != indexMap.end()) {
+                memcpy((char *) indexMap[index], (char *) buffer + offset - sizeof(int) - length, sizeof(int) + length);
+            }
+        } else if (attr.type == TypeInt) {
+            int num = atoi(token);
+            memcpy((char *) buffer + offset, &num, sizeof(num));
+            offset += sizeof(num);
+
+            auto got = indexMap.find(index);
+            if (got != indexMap.end())
+                memcpy((char *) indexMap[index], (char *) buffer + offset - sizeof(int), sizeof(int));
+        } else if (attr.type == TypeReal) {
+            float num = atof(token);
+            memcpy((char *) buffer + offset, &num, sizeof(num));
+            offset += sizeof(num);
+
+            auto got = indexMap.find(index);
+            if (got != indexMap.end())
+                memcpy((char *) indexMap[index], (char *) buffer + offset - sizeof(float), sizeof(int));
+        }
+//    else if (attr.type == TypeBoolean || attr.type == TypeShort) {
+//      return error("I do not wanna add this type of variable");
+//    }
+        token = next();
+        index += 1;
+    }
+    if (this->insertTupleToDB(tableName, attributes, buffer, indexMap) != 0) {
+        return error("error while inserting tuple");
+    }
+
+    // clear up indexMap
+    for (auto it = indexMap.begin(); it != indexMap.end(); ++it) {
+        free(it->second);
+    }
+
+    free(buffer);
+    free(key);
+    return 0;
+}
+
+RC CLI::insertTupleToDB(const string tableName, const vector<Attribute> attributes, const void *data,
+                        unordered_map<int, void *> indexMap) {
+    RID rid;
+
+    // insert data to given table
+    if (rm.insertTuple(tableName, data, rid) != 0)
+        return error("error CLI::insertTuple in rm.insertTuple");
+
+    return 0;
+}
+
+RC CLI::printAttributes() {
+    char *tokenizer = next();
+    if (tokenizer == NULL) {
+        error("I expect tableName to print its attributes/columns");
+        return -1;
+    }
+
+    string tableName = string(tokenizer);
+
+    // get attributes of tableName
+    Attribute attr;
+    vector<Attribute> attributes;
+    this->getAttributesFromCatalog(tableName, attributes);
+
+    // update attributes
+    vector<string> outputBuffer;
+    outputBuffer.push_back("name");
+    outputBuffer.push_back("type");
+    outputBuffer.push_back("length");
+
+    for (std::vector<Attribute>::iterator it = attributes.begin(); it != attributes.end(); ++it) {
+        outputBuffer.push_back(it->name);
+        outputBuffer.push_back(to_string(it->type));
+        outputBuffer.push_back(to_string(it->length));
+    }
+
+    return this->printOutputBuffer(outputBuffer, 3);
+}
+
+RC CLI::printIndex() {
+    char *tokenizer = next();
+    string columnName = string(tokenizer);
+
+    tokenizer = next();
+    if (tokenizer == NULL || !expect(tokenizer, "on")) {
+        return error("syntax error: expecting \"on\"");
+    }
+
+    tokenizer = next();
+    string tableName = string(tokenizer);
+
+    RM_IndexScanIterator rmisi;
+    if (rm.indexScan(tableName, columnName, NULL, NULL, false, false, rmisi) != 0)
+        return error("error in indexScan::printIndex");
+
+    vector<string> outputBuffer;
+    RID rid;
+    char key[PAGE_SIZE];
+
+    outputBuffer.push_back("PageNum");
+    outputBuffer.push_back("SlotNum");
+    while (rmisi.getNextEntry(rid, key) == 0) {
+        outputBuffer.push_back(to_string(rid.pageNum));
+        outputBuffer.push_back(to_string(rid.slotNum));
+    }
+
+    return this->printOutputBuffer(outputBuffer, 2);
+}
+
+// print every tuples in given tableName
+RC CLI::printTable(const string tableName) {
+    vector<Attribute> attributes;
+    RC rc = this->getAttributesFromCatalog(tableName, attributes);
+    if (rc != 0)
+        return error("table: " + tableName + " does not exist");
+
+    // Set up the iterator
+    RM_ScanIterator rmsi;
+    RID rid;
+    void *data_returned = malloc(4096);
+
+
+    // convert attributes to vector<string>
+    vector<string> stringAttributes;
+    for (std::vector<Attribute>::iterator it = attributes.begin(); it != attributes.end(); ++it)
+        stringAttributes.push_back(it->name);
+
+    rc = rm.scan(tableName, "", NO_OP, NULL, stringAttributes, rmsi);
+    if (rc != 0)
+        return rc;
+
+    // print
+    vector<string> outputBuffer;
+    for (std::vector<Attribute>::iterator it = attributes.begin(); it != attributes.end(); ++it) {
+        outputBuffer.push_back(it->name);
+    }
+
+    while ((rc = rmsi.getNextTuple(rid, data_returned)) != RM_EOF) {
+        if (rc != 0) {
+            cout << "fata" << endl;
+            exit(1);
+        }
+
+        if (this->updateOutputBuffer(outputBuffer, data_returned, attributes) != 0) {
+            free(data_returned);
+            return error("problem in updateOutputBuffer");
+        }
+    }
+    rmsi.close();
+    free(data_returned);
+
+    return this->printOutputBuffer(outputBuffer, attributes.size());
+}
+
+RC CLI::help(const string input) {
+    if (input.compare("create") == 0) {
+        cout << "\tcreate table <tableName> (col1 = type1, col2 = type2, ...): creates table with given properties"
+             << endl;
+        cout << "\tcreate index <columnName> on <tableName>: creates index for <columnName> in table <tableName>"
+             << endl;
+        cout << "\tcreate catalog" << endl;
+    } else if (input.compare("add") == 0) {
+        cout << "\tadd attribute \"attributeName=type\" to \"tableName\": drops given table" << endl;
+    } else if (input.compare("drop") == 0) {
+        cout << "\tdrop table <tableName>: drops given table" << endl;
+        cout << "\tdrop index <attributeName> on <tableName>: drops given index" << endl;
+        cout << "\tdrop attribute <attributeName> from <tableName>: drops attributeName from tableName" << endl;
+        cout << "\tdrop catalog" << endl;
+    } else if (input.compare("insert") == 0) {
+        cout << "\tinsert into <tableName> tuple(attr1 = val1, attr2 = value2, ...)";
+        cout << ": inserts given tuple to given tableName" << endl;
+    } else if (input.compare("print") == 0) {
+        cout << "\tprint <tableName>: print every record in tableName" << endl;
+        cout << "\tprint attributes <tableName>: print columns of given tableName" << endl;
+        cout << "\tprint index <attributeName> on <tableName>: print columns of given tableName" << endl;
+    } else if (input.compare("load") == 0) {
+        cout << "\tload <tableName> \"fileName\"";
+        cout << ": loads given filName to given table" << endl;
+    } else if (input.compare("help") == 0) {
+        cout << "\thelp <commandName>: print help for given command" << endl;
+        cout << "\thelp: show help for all commands" << endl;
+    } else if (input.compare("quit") == 0) {
+        cout << "\tquit or exit: quit SecSQL. But remember, love never ends!" << endl;
+    } else if (input.compare("query") == 0) {
+        cout << endl;
+        cout << "\tAll queries start with \"SELECT\"" << endl;
+
+        cout << "\t\t<query> = " << endl;
+        cout << "\t\t\tPROJECT <query> GET \"[\" <attrs> \"]\"" << endl;
+        cout << "\t\t\tFILTER <query> WHERE <attr> <op> <value>" << endl;
+        cout << "\t\t\tBNLJOIN <query>, <query> WHERE <attr> <op> <attr> PAGES(<numPages>)" << endl;
+        cout << "\t\t\tINLJOIN <query>, <query> WHERE <attr> <op> <attr>" << endl;
+        cout << "\t\t\tGHJOIN <query>, <query> WHERE <attr> <op> <attr> PARTITIONS(<numPartitions>)" << endl;
+        cout << "\t\t\tAGG <query> [ GROUPBY(<attr>) ] GET <agg-op>(<attr>)" << endl;
+        cout << "\t\t\tIDXSCAN <query> <attr> <op> <value>" << endl;
+        cout << "\t\t\tTBLSCAN <query>" << endl;
+        cout << "\t\t\t<tableName>" << endl;
+
+        cout << "\t\t<agg-op> = MIN | MAX | SUM | AVG | COUNT" << endl;
+        cout << "\t\t<op> = < | > | = | != | >= | <= | NOOP" << endl;
+        cout << "\t\t<attrs> = <attr> { \",\" <attr> }" << endl;
+        cout << "\t\t<numPages> = is a number bigger than 0" << endl;
+        cout << "\t\t<numPartitions> = is a number bigger than 0" << endl;
+        cout << endl;
+    } else if (input.compare("all") == 0) {
+        help("create");
+        help("drop");
+        help("print");
+        help("insert");
+        help("load");
+        help("help");
+        help("query");
+        help("quit");
+    } else {
+        cout << "I dont know how to help you with <" << input << ">" << endl;
+        return -1;
+    }
+    return 0;
+}
+
+RC CLI::getAttributesFromCatalog(const string tableName, vector<Attribute> &columns) {
+    return rm.getAttributes(tableName, columns);
+}
+
+// Add given table to CLI_TABLES
+RC CLI::addTableToCatalog(const string tableName, const string file_url, const string type) {
+    int offset = 0;
+    int length;
+    void *buffer = malloc(COLUMNS_TABLE_RECORD_MAX_LENGTH);
+
+    // Null-indicators
+    unsigned char *nullsIndicator = (unsigned char *) malloc(1);
+
+    memset(buffer, 0, COLUMNS_TABLE_RECORD_MAX_LENGTH);
+    memset(nullsIndicator, 0, 1);
+
+    // Null-indicator for the fields
+    memcpy((char *) buffer + offset, nullsIndicator, 1);
+    offset += 1;
+
+    length = tableName.size();
+    memcpy((char *) buffer + offset, &length, sizeof(int));
+    offset += sizeof(int);
+    memcpy((char *) buffer + offset, tableName.c_str(), tableName.size());
+    offset += tableName.size();
+
+    length = file_url.size();
+    memcpy((char *) buffer + offset, &length, sizeof(int));
+    offset += sizeof(int);
+    memcpy((char *) buffer + offset, file_url.c_str(), file_url.size());
+    offset += file_url.size();
+
+    length = type.size();
+    memcpy((char *) buffer + offset, &length, sizeof(int));
+    offset += sizeof(int);
+    memcpy((char *) buffer + offset, type.c_str(), type.size());
+    offset += type.size();
+
+    RID rid;
+    RC ret = rm.insertTuple(CLI_TABLES, buffer, rid);
+
+    free(buffer);
+    return ret;
+}
+
+// adds given attribute to CLI_COLUMNS
+RC CLI::addAttributeToCatalog(const Attribute &attr, const string tableName, const int position) {
+    int offset = 0;
+    int length;
+    void *buffer = malloc(COLUMNS_TABLE_RECORD_MAX_LENGTH + 1);
+
+    // Null-indicators
+    unsigned char *nullsIndicator = (unsigned char *) malloc(1);
+
+    memset(buffer, 0, COLUMNS_TABLE_RECORD_MAX_LENGTH + 1);
+    memset(nullsIndicator, 0, 1);
+
+    // Null-indicator for the fields
+    memcpy((char *) buffer + offset, nullsIndicator, 1);
+    offset += 1;
+
+    length = attr.name.size();
+    memcpy((char *) buffer + offset, &length, sizeof(int));
+    offset += sizeof(int);
+    memcpy((char *) buffer + offset, attr.name.c_str(), attr.name.size());
+    offset += attr.name.size();
+
+    length = tableName.size();
+    memcpy((char *) buffer + offset, &length, sizeof(int));
+    offset += sizeof(int);
+    memcpy((char *) buffer + offset, tableName.c_str(), tableName.size());
+    offset += tableName.size();
+
+    memcpy((char *) buffer + offset, &position, sizeof(position));
+    offset += sizeof(position);
+
+    memcpy((char *) buffer + offset, &attr.type, sizeof(attr.type));
+    offset += sizeof(attr.type);
+
+    memcpy((char *) buffer + offset, &attr.length, sizeof(attr.length));
+    offset += sizeof(attr.length);
+
+    RID rid;
+    RC ret = rm.insertTuple(CLI_COLUMNS, buffer, rid);
+
+    free(buffer);
+    return ret;
+}
+
+// Add given index to CLI_INDEXES
+RC CLI::addIndexToCatalog(const string tableName, const string columnName) {
+    // Collect information from the catalog for the columnName
+    vector<Attribute> columns;
+    if (this->getAttributesFromCatalog(tableName, columns) != 0)
+        return -1;
+
+    int max_size = -1;
+    bool is_variable = false;
+    for (uint i = 0; i < columns.size(); i++) {
+        if (columns.at(i).name == columnName) {
+            if (columns.at(i).type == TypeVarChar) {
+                max_size = columns.at(i).length + 2;
+                is_variable = true;
+            } else {
+                max_size = columns.at(i).length;
+            }
+            break;
+        }
+    }
+
+    if (max_size == -1)
+        return error("max-size returns -1");
+
+    int offset = 0;
+    int length;
+    void *buffer = malloc(tableName.size() + columnName.size() + 8 + 4 + 1 + 1);
+
+    // Null-indicators
+    unsigned char *nullsIndicator = (unsigned char *) malloc(1);
+
+    memset(buffer, 0, tableName.size() + columnName.size() + 8 + 4 + 1 + 1);
+    memset(nullsIndicator, 0, 1);
+
+    // Null-indicator for the fields
+    memcpy((char *) buffer + offset, nullsIndicator, 1);
+    offset += 1;
+
+    length = tableName.size();
+    memcpy((char *) buffer + offset, &length, sizeof(int));
+    offset += sizeof(int);
+    memcpy((char *) buffer + offset, tableName.c_str(), tableName.size());
+    offset += tableName.size();
+
+    length = columnName.size();
+    memcpy((char *) buffer + offset, &length, sizeof(int));
+    offset += sizeof(int);
+    memcpy((char *) buffer + offset, columnName.c_str(), columnName.size());
+    offset += length;
+
+    memcpy((char *) buffer + offset, &max_size, sizeof(max_size));
+    offset += sizeof(max_size);
+
+    memcpy((char *) buffer + offset, &is_variable, sizeof(is_variable));
+    offset += sizeof(is_variable);
+
+    RID rid;
+    RC rc = rm.insertTuple(CLI_INDEXES, buffer, rid);
+
+    free(buffer);
+
+    return rc;
+}
+
+RC CLI::history() {
+#ifndef NO_HISTORY_LIST
+    HIST_ENTRY **the_list;
+  int ii;
+  the_list = history_list();
+  if (the_list)
+  for (ii = 0; the_list[ii]; ii++)
+     printf ("%d: %s\n", ii + history_base, the_list[ii]->line);
+#else
+    HIST_ENTRY *the_list;
+    the_list = current_history();
+    vector<string> list;
+    while (the_list) {
+        list.push_back(the_list->line);
+        the_list = next_history();
+    }
+    int tot = list.size();
+    for (int i = tot - 1; i >= 0; i--) {
+        cout << (tot - i) << ": " << list.at(i) << endl;
+    }
+#endif
+    return 0;
+}
+
+// checks whether given tableName-columnName exists or not in cli_columns or cli_indexes
+bool CLI::checkAttribute(const string tableName, const string columnName, RID &rid, bool searchColumns) {
+    string searchTable = CLI_COLUMNS;
+    if (searchColumns == false)
+        searchTable = CLI_INDEXES;
+
+    vector<Attribute> attributes;
+    this->getAttributesFromCatalog(CLI_COLUMNS, attributes);
+
+    // Set up the iterator
+    RM_ScanIterator rmsi;
+    void *data_returned = malloc(PAGE_SIZE);
+
+    // convert attributes to vector<string>
+    vector<string> stringAttributes;
+    //stringAttributes.push_back("column_name");
+    stringAttributes.push_back("table_name");
+
+    int stringSize = columnName.size();
+    void *value = malloc(stringSize + sizeof(unsigned));
+    memcpy((char *) value, &stringSize, sizeof(unsigned));
+    memcpy((char *) value + sizeof(unsigned), columnName.c_str(), stringSize);
+
+    // Find records whose column is columnName
+    if (rm.scan(searchTable, "column_name", EQ_OP, value, stringAttributes, rmsi) != 0)
+        return -1;
+
+    // check if tableName is what we want
+    while (rmsi.getNextTuple(rid, data_returned) != RM_EOF) {
+        int length = 0, offset = 0;
+
+        // adding +1 because of nulls-indicator
+        offset++;
+
+        memcpy(&length, (char *) data_returned + offset, sizeof(int));
+        offset += sizeof(int);
+
+        char *str = (char *) malloc(length + 1);
+        str[length] = '\0';
+
+        memcpy(str, (char *) data_returned + offset, length);
+        offset += length;
+
+        if (tableName.compare(string(str)) == 0) {
+            free(data_returned);
+            free(str);
+            return true;
+        }
+        free(str);
+    }
+    rmsi.close();
+    free(value);
+    free(data_returned);
+    return false;
+}
+
+RC CLI::updateOutputBuffer(vector<string> &buffer, void *data, vector<Attribute> &attrs) {
+    int length, offset = 0, number;
+    float fNumber;
+    char *str;
+    string record = "";
+
+    // Assume that we don't have any NULL values when loading data.
+    // Null-indicators
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attrs.size());
+
+    // Pass Null-indicator for the fields
+    offset += nullAttributesIndicatorActualSize;
+
+    for (std::vector<Attribute>::iterator it = attrs.begin(); it != attrs.end(); ++it) {
+        switch (it->type) {
+            case TypeInt:
+                number = 0;
+                memcpy(&number, (char *) data + offset, sizeof(int));
+                offset += sizeof(int);
+                buffer.push_back(to_string(number));
+                break;
+            case TypeReal:
+                fNumber = 0;
+                memcpy(&fNumber, (char *) data + offset, sizeof(float));
+                offset += sizeof(float);
+                buffer.push_back(to_string(fNumber));
+                break;
+            case TypeVarChar:
+                length = 0;
+                memcpy(&length, (char *) data + offset, sizeof(int));
+
+                if (length == 0) {
+                    buffer.push_back("--");
+                    break;
+                }
+
+                offset += sizeof(int);
+
+                str = (char *) malloc(length + 1);
+                memcpy(str, (char *) data + offset, length);
+                str[length] = '\0';
+                offset += length;
+
+                buffer.push_back(str);
+                free(str);
+                break;
+        }
+    }
+    return 0;
+}
+
+// 2-pass output function
+RC CLI::printOutputBuffer(vector<string> &buffer, uint mod) {
+    // find max for each column
+    uint *maxLengths = new uint[mod];
+    for (uint i = 0; i < mod; i++)
+        maxLengths[i] = 0;
+
+    int index;
+    for (uint i = 0; i < buffer.size(); i++) {
+        index = i % mod;
+        maxLengths[index] = fmax(maxLengths[index], buffer.at(i).size());
+    }
+
+    uint startIndex = 0;
+    int totalLength = 0;
+
+    for (uint i = 0; i < mod; i++) {
+        cout << setw(maxLengths[i]) << left << buffer[i] << DIVISOR;
+        totalLength += maxLengths[i] + DIVISOR_LENGTH;
+    }
+    cout << endl;
+
+    // totalLength - 2 because I do not want to count for extra spaces after last column
+    for (int i = 0; i < totalLength - 2; i++)
+        cout << "=";
+    startIndex = mod;
+
+    // output columns
+    for (uint i = startIndex; i < buffer.size(); i++) {
+        if (i % mod == 0)
+            cout << endl;
+        cout << setw(maxLengths[i % mod]) << left << buffer[i] << DIVISOR;
+    }
+    cout << endl;
+    delete[] maxLengths;
+    return 0;
+}
+
+// advance tokenizer to next token
+char *CLI::next() {
+    return strtok(NULL, DELIMITERS);
+}
+
+bool CLI::expect(const string token, const string expected) {
+    return expect(token.c_str(), expected);
+}
+
+// return 0 if tokenizer is equal to expected string
+bool CLI::expect(const char *token, const string expected) {
+    if (token == NULL) {
+        error("tokenizer is null, expecting: " + expected);
+        return -1;
+    }
+    string s1 = toLower(string(token));
+    string s2 = toLower(expected);
+    return s1.compare(s2) == 0;
+}
+
+string CLI::toLower(string data) {
+    std::transform(data.begin(), data.end(), data.begin(), ::tolower);
+    return data;
+}
+
+RC CLI::error(const string errorMessage) {
+    cout << errorMessage << endl;
+    return -2;
+}
+
+RC CLI::error(uint errorCode) {
+    cout << errorCode << endl;
+    return -3;
+}
+
+RC CLI::getAttribute(const string name, const vector<Attribute> pool, Attribute &attr) {
+    for (uint i = 0; i < pool.size(); i++) {
+        if (0 == pool.at(i).name.compare(name)) {
+            attr = pool[i];
+            return 0;
+        }
+    }
+    return error("attribute cannot be found");
+}
+
+RC CLI::getAttribute(const string tableName, const string attrName, Attribute &attr) {
+    vector<Attribute> attrs;
+    if (this->getAttributesFromCatalog(tableName, attrs) != 0)
+        return error(__LINE__);
+    return getAttribute(attrName, attrs, attr);
+}
+
+void CLI::addTableNameToAttrs(const string tableName, vector<string> &attrs) {
+    for (uint i = 0; i < attrs.size(); i++)
+        attrs[i] = fullyQualify(attrs.at(i), tableName);
+}
\ No newline at end of file
diff --git a/cli/cli.h b/cli/cli.h
new file mode 100755
index 0000000..c123237
--- /dev/null
+++ b/cli/cli.h
@@ -0,0 +1,164 @@
+#ifndef _cli_h_
+#define _cli_h_
+
+#include <string>
+#include <cstring>
+#include <cassert>
+#include <iomanip>
+#include <cmath>
+#include <algorithm>
+#include <iostream>
+#include <unordered_map>
+
+#ifdef __APPLE__
+#define uint uint32_t
+#define NO_HISTORY_LIST
+#endif
+
+#include "../rbf/pfm.h"
+#include "../rbf/rbfm.h"
+#include "../rm/rm.h"
+#include "../ix/ix.h"
+#include "../qe/qe.h"
+
+typedef enum {
+    FILTER = 0, PROJECT, BNL_JOIN, INL_JOIN, GH_JOIN, AGG, IDX_SCAN, TBL_SCAN
+} QUERY_OP;
+
+// Return code
+typedef int RC;
+
+struct Table {
+    std::string tableName;
+    std::vector<Attribute> columns;
+
+};
+
+// Record Manager
+class CLI {
+public:
+    static CLI *Instance();
+
+    RC process(const std::string input);
+
+    RC start();
+
+protected:
+    CLI();
+
+    ~CLI();
+
+private:
+    // cli parsers
+    RC createTable();
+
+    RC createIndex();
+
+    RC createCatalog();
+
+    RC dropTable();
+
+    RC dropIndex(const std::string tableName = "", const std::string columnName = "", bool fromCommand = true);
+
+    RC dropCatalog();
+
+    RC addAttribute();
+
+    RC insertTuple();
+
+    RC dropAttribute();
+
+    RC load();
+
+    RC printTable(const std::string tableName);
+
+    RC printAttributes();
+
+    RC printIndex();
+
+    RC help(const std::string input);
+
+    RC history();
+
+    // query parsers
+    // code [0,4]: operation number
+    // code -1: operation not found
+    // code -2: don't call isIterator
+    Iterator *query(Iterator *previous, int code = -1);
+
+    Iterator *createBaseScanner(const std::string token);
+
+    Iterator *projection(Iterator *input);
+
+    Iterator *filter(Iterator *input);
+
+    Iterator *blocknestedloopjoin(Iterator *input);
+
+    Iterator *indexnestedloopjoin(Iterator *input);
+
+    Iterator *gracehashjoin(Iterator *input);
+
+    Iterator *aggregate(Iterator *input);
+
+    // run the query
+    RC run(Iterator *);
+
+    RC createProjectAttributes(const std::string tableName, std::vector<Attribute> &attrs);
+
+    RC createCondition(const std::string tableName, Condition &condition, const bool join = false,
+                       const std::string joinTable = "");
+
+    RC createAttribute(Iterator *, Attribute &attr);
+
+    RC createAggregateOp(const std::string operation, AggregateOp &op);
+
+    void addTableNameToAttrs(const std::string tableName, std::vector<std::string> &attrs);
+
+    bool isIterator(const std::string token, int &code);
+
+    std::string getTableName(Iterator *it);
+
+    std::string getAttribute(const std::string input);
+
+    std::string fullyQualify(const std::string attribute, const std::string tableName);
+
+    // cli catalog functions
+    RC getAttributesFromCatalog(const std::string tableName, std::vector<Attribute> &columns);
+
+    RC getAttribute(const std::string tableName, const std::string attrName, Attribute &attr);
+
+    RC addAttributeToCatalog(const Attribute &attr, const std::string tableName, const int position);
+
+    RC addTableToCatalog(const std::string tableName, const std::string file_url, const std::string type);
+
+    RC addIndexToCatalog(const std::string tableName, const std::string indexName);
+
+    // helper functions
+    char *next();
+
+    bool expect(const std::string token, const std::string expected);
+
+    bool expect(const char *token, const std::string expected);
+
+    std::string toLower(std::string input);
+
+    bool checkAttribute(const std::string tableName, const std::string columnName, RID &rid, bool searchColumns = true);
+
+    RC error(const std::string errorMessage);
+
+    RC error(uint errorCode);
+
+    RC printOutputBuffer(std::vector<std::string> &buffer, uint mod);
+
+    RC updateOutputBuffer(std::vector<std::string> &buffer, void *data, std::vector<Attribute> &attrs);
+
+    RC insertTupleToDB(const std::string tableName, const std::vector<Attribute> attributes, const void *data,
+                       std::unordered_map<int, void *> indexMap);
+
+    RC getAttribute(const std::string name, const std::vector<Attribute> pool, Attribute &attr);
+
+    RelationManager &rm = RelationManager::instance();
+    static CLI *_cli;
+};
+
+#endif
diff --git a/cli/cli_example_01.cc b/cli/cli_example_01.cc
new file mode 100755
index 0000000..a303406
--- /dev/null
+++ b/cli/cli_example_01.cc
@@ -0,0 +1,56 @@
+#include "cli.h"
+
+#define SUCCESS 0
+#define MODE 0  // 0 = TEST MODE
+// 1 = INTERACTIVE MODE
+// 3 = TEST + INTERACTIVE MODE
+
+CLI *cli;
+
+void exec(const std::string &command, bool equal = true) {
+    std::cout << ">>> " << command << std::endl;
+
+    if (equal)
+        assert (cli->process(command) == SUCCESS);
+    else
+        assert (cli->process(command) != SUCCESS);
+}
+
+// test create table
+// test drop table
+void Test01() {
+
+    std::cout << "*********** CLI Test01 begins ******************" << std::endl;
+
+    std::string command;
+
+    exec("create catalog");
+
+    exec("create table ekin name = varchar(40), age = int");
+
+    exec("print cli_columns");
+
+    exec("print cli_tables");
+
+    exec("drop table ekin");
+
+    exec("print cli_tables");
+
+    exec("print cli_columns");
+
+    std::cout << "We should not see anything related to ekin table" << std::endl;
+}
+
+int main() {
+
+    cli = CLI::Instance();
+
+    if (MODE == 0 || MODE == 3) {
+        Test01();
+    }
+    if (MODE == 1 || MODE == 3) {
+        cli->start();
+    }
+
+    return 0;
+}
diff --git a/cli/cli_example_02.cc b/cli/cli_example_02.cc
new file mode 100755
index 0000000..0238023
--- /dev/null
+++ b/cli/cli_example_02.cc
@@ -0,0 +1,52 @@
+#include "cli.h"
+
+#define SUCCESS 0
+#define MODE 0  // 0 = TEST MODE
+// 1 = INTERACTIVE MODE
+// 3 = TEST + INTERACTIVE MODE
+
+CLI *cli;
+
+void exec(const std::string &command, bool equal = true) {
+    std::cout << ">>> " << command << std::endl;
+
+    if (equal)
+        assert (cli->process(command) == SUCCESS);
+    else
+        assert (cli->process(command) != SUCCESS);
+}
+
+// test create table
+// test load table
+void Test02() {
+
+    std::cout << "*********** CLI Test02 begins ******************" << std::endl;
+
+    std::string command;
+
+    exec("create table tbl_employee EmpName = varchar(30), Age = int, Height = real, Salary = int");
+
+    std::cout << "Before loading file: " << std::endl;
+    exec("print tbl_employee");
+
+    exec("load tbl_employee employee_50");
+
+    std::cout << "After loading file: " << std::endl;
+    exec("print tbl_employee");
+
+    exec(("drop table tbl_employee"));
+}
+
+int main() {
+
+    cli = CLI::Instance();
+
+    if (MODE == 0 || MODE == 3) {
+        Test02();
+    }
+    if (MODE == 1 || MODE == 3) {
+        cli->start();
+    }
+
+    return 0;
+}
diff --git a/cli/cli_example_03.cc b/cli/cli_example_03.cc
new file mode 100755
index 0000000..0e44603
--- /dev/null
+++ b/cli/cli_example_03.cc
@@ -0,0 +1,60 @@
+#include "cli.h"
+
+#define SUCCESS 0
+#define MODE 0  // 0 = TEST MODE
+// 1 = INTERACTIVE MODE
+// 3 = TEST + INTERACTIVE MODE
+
+CLI *cli;
+
+void exec(const std::string &command, bool equal = true) {
+    std::cout << ">>> " << command << std::endl;
+
+    if (equal)
+        assert (cli->process(command) == SUCCESS);
+    else
+        assert (cli->process(command) != SUCCESS);
+}
+
+// test Table Scan
+void Test03() {
+    std::cout << "*********** CLI Test03 begins ******************" << std::endl;
+
+    std::string command;
+
+    exec("create table employee EmpName = varchar(30), Age = int, Height = real, Salary = int");
+
+    exec("create table ages Age = int, Explanation = varchar(50)");
+
+    exec("create table salary Salary = int, Explanation = varchar(50)");
+
+    exec("load employee employee_5");
+
+    exec("load ages ages_90");
+
+    exec("load salary salary_5");
+
+    exec("SELECT TBLSCAN employee");
+
+    exec("SELECT TBLSCAN ages");
+
+    exec("SELECT TBLSCAN salary");
+
+    exec(("drop table employee"));
+    exec(("drop table ages"));
+    exec(("drop table salary"));
+}
+
+int main() {
+
+    cli = CLI::Instance();
+
+    if (MODE == 0 || MODE == 3) {
+        Test03(); // TableScan
+    }
+    if (MODE == 1 || MODE == 3) {
+        cli->start();
+    }
+
+    return 0;
+}
diff --git a/cli/cli_example_04.cc b/cli/cli_example_04.cc
new file mode 100755
index 0000000..6ea2ec6
--- /dev/null
+++ b/cli/cli_example_04.cc
@@ -0,0 +1,57 @@
+#include "cli.h"
+
+#define SUCCESS 0
+#define MODE 0  // 0 = TEST MODE
+// 1 = INTERACTIVE MODE
+// 3 = TEST + INTERACTIVE MODE
+
+CLI *cli;
+
+void exec(const std::string &command, bool equal = true) {
+    std::cout << ">>> " << command << std::endl;
+
+    if (equal)
+        assert (cli->process(command) == SUCCESS);
+    else
+        assert (cli->process(command) != SUCCESS);
+}
+
+// Projection Test
+void Test04() {
+    std::cout << "*********** CLI Test04 begins ******************" << std::endl;
+
+    std::string command;
+
+    exec("create table tbl_employee EmpName = varchar(30), Age = int, Height = real, Salary = int");
+
+    exec("load tbl_employee employee_5");
+
+    exec("print tbl_employee");
+
+    exec("SELECT PROJECT tbl_employee GET [ * ]");
+
+    exec("SELECT PROJECT (PROJECT tbl_employee GET [ * ]) GET [ EmpName ]");
+
+    exec("SELECT PROJECT (PROJECT tbl_employee GET [ EmpName, Age ]) GET [ Age ]");
+
+    exec("SELECT PROJECT (PROJECT (PROJECT tbl_employee GET [ * ]) GET [ EmpName, Age ]) GET [ Age ]");
+
+    exec("SELECT PROJECT tbl_employee GET [ EmpName, Age ]");
+
+    exec(("drop table tbl_employee"));
+
+}
+
+int main() {
+
+    cli = CLI::Instance();
+
+    if (MODE == 0 || MODE == 3) {
+        Test04(); // Projection
+    }
+    if (MODE == 1 || MODE == 3) {
+        cli->start();
+    }
+
+    return 0;
+}
diff --git a/cli/cli_example_05.cc b/cli/cli_example_05.cc
new file mode 100755
index 0000000..5f4ce53
--- /dev/null
+++ b/cli/cli_example_05.cc
@@ -0,0 +1,68 @@
+#include "cli.h"
+
+#define SUCCESS 0
+#define MODE 0  // 0 = TEST MODE
+// 1 = INTERACTIVE MODE
+// 3 = TEST + INTERACTIVE MODE
+
+CLI *cli;
+
+void exec(std::string command, bool equal = true) {
+    std::cout << ">>> " << command << std::endl;
+
+    if (equal)
+        assert (cli->process(command) == SUCCESS);
+    else
+        assert (cli->process(command) != SUCCESS);
+}
+
+// Filter Test
+void Test05() {
+    std::cout << "*********** CLI Test05 begins ******************" << std::endl;
+
+    std::string command;
+
+    exec("create table tbl_employee EmpName = varchar(30), Age = int, Height = real, Salary = int");
+
+    exec("load tbl_employee employee_5");
+
+    exec("print tbl_employee");
+
+    exec("SELECT FILTER tbl_employee WHERE Age = 45");
+
+    exec("SELECT FILTER tbl_employee WHERE Age < 45");
+
+    exec("SELECT FILTER tbl_employee WHERE Age > 45");
+
+    exec("SELECT FILTER tbl_employee WHERE Age <= 45");
+
+    exec("SELECT FILTER tbl_employee WHERE Age >= 45");
+
+    exec("SELECT FILTER tbl_employee WHERE Age != 45");
+
+    exec("SELECT FILTER tbl_employee WHERE Height < 6.3");
+
+    exec("SELECT FILTER tbl_employee WHERE EmpName < L");
+
+    exec("SELECT FILTER (FILTER tbl_employee WHERE  Age < 67) WHERE EmpName < L");
+
+    exec("SELECT FILTER (FILTER tbl_employee WHERE  Age <= 67) WHERE Height >= 6.4");
+
+    exec("SELECT FILTER (FILTER (FILTER tbl_employee WHERE EmpName > Ap) WHERE  Age <= 67) WHERE Height >= 6.4");
+
+    exec(("drop table tbl_employee"));
+}
+
+int main() {
+
+    cli = CLI::Instance();
+
+    if (MODE == 0 || MODE == 3) {
+        Test05(); // Filter
+    }
+    if (MODE == 1 || MODE == 3) {
+        cli->start();
+    }
+
+    return 0;
+}
diff --git a/cli/cli_example_06.cc b/cli/cli_example_06.cc
new file mode 100755
index 0000000..52738ef
--- /dev/null
+++ b/cli/cli_example_06.cc
@@ -0,0 +1,62 @@
+#include "cli.h"
+
+#define SUCCESS 0
+#define MODE 0  // 0 = TEST MODE
+// 1 = INTERACTIVE MODE
+// 3 = TEST + INTERACTIVE MODE
+
+CLI *cli;
+
+void exec(const std::string &command, bool equal = true) {
+    std::cout << ">>> " << command << std::endl;
+
+    if (equal)
+        assert (cli->process(command) == SUCCESS);
+    else
+        assert (cli->process(command) != SUCCESS);
+}
+
+// Projection + Filter Test
+void Test06() {
+    std::cout << "*********** CLI Test06 begins ******************" << std::endl;
+
+    std::string command;
+
+    exec("create table tbl_employee EmpName = varchar(30), Age = int, Height = real, Salary = int");
+
+    exec("load tbl_employee employee_5");
+
+    exec("print tbl_employee");
+
+    exec("SELECT FILTER tbl_employee WHERE Age != 45");
+
+    exec("SELECT PROJECT (FILTER tbl_employee WHERE Age != 45) GET [ Age ]");
+
+    exec("SELECT PROJECT (FILTER tbl_employee WHERE Age != 45) GET [ EmpName, Age ]");
+
+    exec("SELECT PROJECT (FILTER tbl_employee WHERE Age != 45) GET [ EmpName, Height ]");
+
+    exec("SELECT PROJECT (FILTER tbl_employee WHERE Age != 45) GET [ * ]");
+
+    exec("SELECT FILTER (PROJECT tbl_employee GET [ EmpName, Age ]) WHERE Age != 45");
+
+    exec("SELECT FILTER (PROJECT tbl_employee GET [ EmpName, Age ]) WHERE Age >= 45");
+
+    exec("SELECT PROJECT (FILTER (PROJECT tbl_employee GET [ EmpName, Age ]) WHERE Age >= 45) GET [ EmpName ]");
+
+    exec(("drop table tbl_employee"));
+}
+
+int main() {
+
+    cli = CLI::Instance();
+
+    if (MODE == 0 || MODE == 3) {
+        Test06(); // Projection + Filter
+    }
+    if (MODE == 1 || MODE == 3) {
+        cli->start();
+    }
+
+    return 0;
+}
diff --git a/cli/cli_example_07.cc b/cli/cli_example_07.cc
new file mode 100755
index 0000000..723b27d
--- /dev/null
+++ b/cli/cli_example_07.cc
@@ -0,0 +1,64 @@
+#include "cli.h"
+
+using namespace std;
+
+#define SUCCESS 0
+#define MODE 0  // 0 = TEST MODE
+// 1 = INTERACTIVE MODE
+// 3 = TEST + INTERACTIVE MODE
+
+CLI *cli;
+
+void exec(const string &command, bool equal = true) {
+    cout << ">>> " << command << endl;
+
+    if (equal)
+        assert (cli->process(command) == SUCCESS);
+    else
+        assert (cli->process(command) != SUCCESS);
+}
+
+// Grace Hash Join
+void Test07() {
+    cout << "*********** CLI Test07 begins ******************" << endl;
+
+    string command;
+
+    exec("create table employee EmpName = varchar(30), Age = int, Height = real, Salary = int");
+
+    exec("create table ages Age = int, Explanation = varchar(50)");
+
+    exec("create table salary Salary = int, Explanation = varchar(50)");
+
+    exec("load employee employee_5");
+
+    exec("load ages ages_90");
+
+    exec("load salary salary_5");
+
+    exec("SELECT GHJOIN employee, ages WHERE Age = Age PARTITIONS(10)");
+
+    exec("SELECT GHJOIN (GHJOIN employee, salary WHERE Salary = Salary PARTITIONS(10)), ages WHERE Age = Age PARTITIONS(10)");
+
+    exec("SELECT GHJOIN (GHJOIN (GHJOIN employee, employee WHERE EmpName = EmpName PARTITIONS(10)), salary) WHERE Salary = Salary PARTITIONS(10)), ages WHERE Age = Age PARTITIONS(10)");
+
+    exec(("drop table employee"));
+
+    exec(("drop table ages"));
+
+    exec(("drop table salary"));
+}
+
+int main() {
+
+    cli = CLI::Instance();
+
+    if (MODE == 0 || MODE == 3) {
+        Test07(); // GHJoin
+    }
+    if (MODE == 1 || MODE == 3) {
+        cli->start();
+    }
+
+    return 0;
+}
diff --git a/cli/cli_example_08.cc b/cli/cli_example_08.cc
new file mode 100755
index 0000000..e0837e3
--- /dev/null
+++ b/cli/cli_example_08.cc
@@ -0,0 +1,62 @@
+#include "cli.h"
+
+#define SUCCESS 0
+#define MODE 0  // 0 = TEST MODE
+// 1 = INTERACTIVE MODE
+// 3 = TEST + INTERACTIVE MODE
+
+CLI *cli;
+
+void exec(const std::string &command, bool equal = true) {
+    std::cout << ">>> " << command << std::endl;
+
+    if (equal)
+        assert (cli->process(command) == SUCCESS);
+    else
+        assert (cli->process(command) != SUCCESS);
+}
+
+// Block Nested Loop Join
+void Test08() {
+    std::cout << "*********** CLI Test08 begins ******************" << std::endl;
+
+    std::string command;
+
+    exec("create table employee EmpName = varchar(30), Age = int, Height = real, Salary = int");
+
+    exec("create table ages Age = int, Explanation = varchar(50)");
+
+    exec("create table salary Salary = int, Explanation = varchar(50)");
+
+    exec("load employee employee_5");
+
+    exec("load ages ages_90");
+
+    exec("load salary salary_5");
+
+    exec("SELECT BNLJOIN employee, ages WHERE Age = Age PAGES(10)");
+
+    exec("SELECT BNLJOIN (BNLJOIN employee, salary WHERE Salary = Salary RECORDS(10)), ages WHERE Age = Age PAGES(10)");
+
+    exec("SELECT BNLJOIN (BNLJOIN (BNLJOIN employee, employee WHERE EmpName = EmpName PAGES(10)), salary) WHERE Salary = Salary PAGES(10)), ages WHERE Age = Age PAGES(10)");
+
+    exec(("drop table employee"));
+
+    exec(("drop table ages"));
+
+    exec(("drop table salary"));
+}
+
+int main() {
+
+    cli = CLI::Instance();
+
+    if (MODE == 0 || MODE == 3) {
+        Test08(); // BNLJoin
+    }
+    if (MODE == 1 || MODE == 3) {
+        cli->start();
+    }
+
+    return 0;
+}
diff --git a/cli/cli_example_09.cc b/cli/cli_example_09.cc
new file mode 100755
index 0000000..8bf235a
--- /dev/null
+++ b/cli/cli_example_09.cc
@@ -0,0 +1,68 @@
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
+#include <string>
+#include <cassert>
+
+#include "cli.h"
+
+using namespace std;
+
+#define SUCCESS 0
+#define MODE 0  // 0 = TEST MODE
+// 1 = INTERACTIVE MODE
+// 3 = TEST + INTERACTIVE MODE
+
+CLI *cli;
+
+void exec(string command, bool equal = true) {
+    cout << ">>> " << command << endl;
+
+    if (equal)
+        assert (cli->process(command) == SUCCESS);
+    else
+        assert (cli->process(command) != SUCCESS);
+}
+
+// Basic aggregation
+void Test09() {
+    cout << "*********** CLI Test09 begins ******************" << endl;
+
+    string command;
+
+    exec("create table employee EmpName = varchar(30), Age = int, Height = real, Salary = int");
+
+    exec("load employee employee_5");
+
+    exec("print employee");
+
+    exec("SELECT AGG employee GET MAX(Height)");
+
+    exec("SELECT AGG employee GET MIN(Salary)");
+
+    exec("SELECT AGG (PROJECT employee GET [ * ]) GET MAX(Salary)");
+
+    exec("SELECT AGG (PROJECT employee GET [ Salary ]) GET SUM(Salary)");
+
+    exec("SELECT AGG (PROJECT employee GET [ Salary ]) GET COUNT(Salary)");
+
+    exec("SELECT AGG (PROJECT employee GET [ Salary ]) GET AVG(Salary)");
+
+    exec("SELECT AGG (PROJECT employee GET [ * ]) GET COUNT(Height)");
+
+    exec(("drop table employee"));
+}
+
+int main() {
+
+    cli = CLI::Instance();
+
+    if (MODE == 0 || MODE == 3) {
+        Test09(); // Basic aggregation
+    }
+    if (MODE == 1 || MODE == 3) {
+        cli->start();
+    }
+
+    return 0;
+}
diff --git a/cli/cli_example_10.cc b/cli/cli_example_10.cc
new file mode 100755
index 0000000..80818cd
--- /dev/null
+++ b/cli/cli_example_10.cc
@@ -0,0 +1,64 @@
+#include "cli.h"
+
+#define SUCCESS 0
+#define MODE 0  // 0 = TEST MODE
+// 1 = INTERACTIVE MODE
+// 3 = TEST + INTERACTIVE MODE
+
+CLI *cli;
+
+void exec(const std::string &command, bool equal = true) {
+    std::cout << ">>> " << command << std::endl;
+
+    if (equal)
+        assert (cli->process(command) == SUCCESS);
+    else
+        assert (cli->process(command) != SUCCESS);
+}
+
+// Group-based hash aggregation
+void Test10() {
+    std::cout << "*********** CLI Test10 begins ******************" << std::endl;
+
+    std::string command;
+
+    exec("create table employee EmpName = varchar(30), Age = int, Height = real, Salary = int");
+
+    exec("create table ages Age = int, Explanation = varchar(50)");
+
+    exec("create table salary Salary = int, Explanation = varchar(50)");
+
+    exec("load employee employee_5");
+
+    exec("load ages ages_90");
+
+    exec("load salary salary_5");
+
+    exec("SELECT AGG ages GROUPBY(Explanation) GET AVG(Age) PARTITIONS(10)");
+
+    exec("SELECT AGG ages GROUPBY(Explanation) GET MIN(Age) PARTITIONS(10)");
+
+    exec("SELECT AGG (PROJECT ages GET [ Age, Explanation ]) GROUPBY(Explanation) GET MIN(Age) PARTITIONS(10)");
+
+    exec("SELECT AGG (FILTER ages WHERE Age > 14) GROUPBY(Explanation) GET MIN(Age) PARTITIONS(10)");
+
+    exec(("drop table employee"));
+
+    exec(("drop table salary"));
+
+    exec(("drop table ages"));
+}
+
+int main() {
+
+    cli = CLI::Instance();
+
+    if (MODE == 0 || MODE == 3) {
+        Test10(); // Group-based hash aggregation
+    }
+    if (MODE == 1 || MODE == 3) {
+        cli->start();
+    }
+
+    return 0;
+}
diff --git a/cli/cli_example_11.cc b/cli/cli_example_11.cc
new file mode 100755
index 0000000..8218d3e
--- /dev/null
+++ b/cli/cli_example_11.cc
@@ -0,0 +1,50 @@
+#include "cli.h"
+
+#define SUCCESS 0
+#define MODE 0  // 0 = TEST MODE
+// 1 = INTERACTIVE MODE
+// 3 = TEST + INTERACTIVE MODE
+
+CLI *cli;
+
+void exec(const std::string &command, bool equal = true) {
+    std::cout << ">>> " << command << std::endl;
+
+    if (equal)
+        assert (cli->process(command) == SUCCESS);
+    else
+        assert (cli->process(command) != SUCCESS);
+}
+
+// IndexScan
+void Test11() {
+
+    std::cout << "*********** CLI Test11 begins ******************" << std::endl;
+
+    std::string command;
+
+    exec("create table employee EmpName = varchar(30), Age = int, Height = real, Salary = int");
+
+    exec("load employee employee_5");
+
+    exec("create index Height on employee");
+    exec("SELECT PROJECT IDXSCAN employee (Height > 5.7) GET [ * ]");
+    exec("SELECT PROJECT IDXSCAN employee (Height < 6.4) GET [ * ]");
+    exec("SELECT PROJECT IDXSCAN employee (Height = 6.6) GET [ * ]");
+
+    exec(("drop table employee"));
+}
+
+int main() {
+
+    cli = CLI::Instance();
+
+    if (MODE == 0 || MODE == 3) {
+        Test11(); // IndexScan
+    }
+    if (MODE == 1 || MODE == 3) {
+        cli->start();
+    }
+
+    return 0;
+}
diff --git a/cli/cli_example_12.cc b/cli/cli_example_12.cc
new file mode 100755
index 0000000..3f9318c
--- /dev/null
+++ b/cli/cli_example_12.cc
@@ -0,0 +1,58 @@
+#include "cli.h"
+
+#define SUCCESS 0
+#define MODE 0  // 0 = TEST MODE
+// 1 = INTERACTIVE MODE
+// 3 = TEST + INTERACTIVE MODE
+
+CLI *cli;
+
+void exec(const std::string &command, bool equal = true) {
+    std::cout << ">>> " << command << std::endl;
+
+    if (equal)
+        assert (cli->process(command) == SUCCESS);
+    else
+        assert (cli->process(command) != SUCCESS);
+}
+
+// INLJoin
+void Test12() {
+    std::cout << "*********** CLI Test12 begins ******************" << std::endl;
+
+    std::string command;
+
+    exec("create table employee EmpName = varchar(30), Age = int, Height = real, Salary = int");
+    exec("create table ages Age = int, Explanation = varchar(50)");
+    exec("create table salary Salary = int, Explanation = varchar(50)");
+
+    exec("load employee employee_5");
+    exec("load ages ages_90");
+    exec("load salary salary_5");
+
+    exec("create index Age on employee");
+    exec("create index Age on ages");
+    exec("create index Salary on employee");
+    exec("create index Salary on salary");
+
+    exec("SELECT INLJOIN employee, ages WHERE Age = Age");
+    exec("SELECT INLJOIN (INLJOIN employee, salary WHERE Salary = Salary), ages WHERE Age = Age");
+
+    exec(("drop table employee"));
+    exec(("drop table ages"));
+    exec(("drop table salary"));
+}
+
+int main() {
+
+    cli = CLI::Instance();
+
+    if (MODE == 0 || MODE == 3) {
+        Test12(); // INLJoin
+    }
+    if (MODE == 1 || MODE == 3) {
+        cli->start();
+    }
+
+    return 0;
+}
diff --git a/cli/makefile b/cli/makefile
new file mode 100755
index 0000000..40f59be
--- /dev/null
+++ b/cli/makefile
@@ -0,0 +1,60 @@
+include ../makefile.inc
+
+all: libcli.a cli_example_01 cli_example_02 cli_example_03 cli_example_04 cli_example_05 cli_example_06 cli_example_07 cli_example_08 cli_example_09 cli_example_10 cli_example_11 cli_example_12 start
+
+# lib file dependencies
+libcli.a: libcli.a(cli.o)  # and possibly other .o files
+
+# c file dependencies
+cli.o: cli.h
+cli_example_01.o: cli.h
+cli_example_02.o: cli.h
+cli_example_03.o: cli.h
+cli_example_04.o: cli.h
+cli_example_05.o: cli.h
+cli_example_06.o: cli.h
+cli_example_07.o: cli.h
+cli_example_08.o: cli.h
+cli_example_09.o: cli.h
+cli_example_10.o: cli.h
+cli_example_11.o: cli.h
+cli_example_12.o: cli.h
+start.o: cli.h
+
+# binary dependencies
+cli_example_01: cli_example_01.o libcli.a $(CODEROOT)/rbf/librbf.a $(CODEROOT)/rm/librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/qe/libqe.a
+cli_example_02: cli_example_02.o libcli.a $(CODEROOT)/rbf/librbf.a $(CODEROOT)/rm/librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/qe/libqe.a
+cli_example_03: cli_example_03.o libcli.a $(CODEROOT)/rbf/librbf.a $(CODEROOT)/rm/librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/qe/libqe.a
+cli_example_04: cli_example_04.o libcli.a $(CODEROOT)/rbf/librbf.a $(CODEROOT)/rm/librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/qe/libqe.a
+cli_example_05: cli_example_05.o libcli.a $(CODEROOT)/rbf/librbf.a $(CODEROOT)/rm/librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/qe/libqe.a
+cli_example_06: cli_example_06.o libcli.a $(CODEROOT)/rbf/librbf.a $(CODEROOT)/rm/librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/qe/libqe.a
+cli_example_07: cli_example_07.o libcli.a $(CODEROOT)/rbf/librbf.a $(CODEROOT)/rm/librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/qe/libqe.a
+cli_example_08: cli_example_08.o libcli.a $(CODEROOT)/rbf/librbf.a $(CODEROOT)/rm/librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/qe/libqe.a
+cli_example_09: cli_example_09.o libcli.a $(CODEROOT)/rbf/librbf.a $(CODEROOT)/rm/librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/qe/libqe.a
+cli_example_10: cli_example_10.o libcli.a $(CODEROOT)/rbf/librbf.a $(CODEROOT)/rm/librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/qe/libqe.a
+cli_example_11: cli_example_11.o libcli.a $(CODEROOT)/rbf/librbf.a $(CODEROOT)/rm/librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/qe/libqe.a
+cli_example_12: cli_example_12.o libcli.a $(CODEROOT)/rbf/librbf.a $(CODEROOT)/rm/librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/qe/libqe.a
+start: start.o libcli.a $(CODEROOT)/rbf/librbf.a $(CODEROOT)/rm/librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/qe/libqe.a
+
+$(CODEROOT)/rm/librm.a:
+	$(MAKE) -C $(CODEROOT)/rm librm.a
+
+$(CODEROOT)/rbf/librbf.a:
+	$(MAKE) -C $(CODEROOT)/rbf librbf.a
+
+# dependencies to compile used libraries
+.PHONY: $(CODEROOT)/rbf/librbf.a $(CODEROOT)/rm/librm.a
+$(CODEROOT)/ix/libix.a:
+	$(MAKE) -C $(CODEROOT)/ix libix.a
+
+.PHONY: $(CODEROOT)/pf/libpf.a $(CODEROOT)/rm/librm.a $(CODEROOT)/ix/libix.a
+$(CODEROOT)/qe/libqe.a:
+	$(MAKE) -C $(CODEROOT)/qe libqe.a
+
+.PHONY: clean
+clean:
+	-rm cli_example_01 cli_example_02 cli_example_03 cli_example_04 cli_example_05 cli_example_06 cli_example_07 cli_example_08 cli_example_09 cli_example_10 cli_example_11 cli_example_12 start *.a *.o *~ ages cli_columns cli_indexes cli_tables employee salary Tables Columns
+	$(MAKE) -C $(CODEROOT)/rbf clean
+	$(MAKE) -C $(CODEROOT)/rm clean
+	$(MAKE) -C $(CODEROOT)/ix clean
+	$(MAKE) -C $(CODEROOT)/qe clean
\ No newline at end of file
diff --git a/cli/start.cc b/cli/start.cc
new file mode 100755
index 0000000..4d9ccf8
--- /dev/null
+++ b/cli/start.cc
@@ -0,0 +1,44 @@
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
+#include <string>
+#include <cassert>
+
+#include "cli.h"
+
+using namespace std;
+
+bool DEMO = false;
+
+CLI *cli;
+
+void exec(string command) {
+    cout << ">>> " << command << endl;
+    cli->process(command);
+}
+
+int main() {
+
+    cli = CLI::Instance();
+    if (DEMO) {
+        exec("create table employee EmpName = varchar(30), Age = int, Height = real, Salary = int");
+        exec("create table ages Age = int, Explanation = varchar(50)");
+        exec("create table salary Salary = int, Explanation = varchar(50)");
+        exec("create table company CompName = varchar(50), Age = int");
+
+        exec("load employee employee_5");
+        exec("load ages ages_90");
+        exec("load salary salary_5");
+        exec("load company company_7");
+
+        exec("create index Age on employee");
+        exec("create index Age on ages");
+        exec("create index Salary on employee");
+        exec("create index Salary on salary");
+        exec("create index Age on company");
+    }
+
+    cli->start();
+
+    return 0;
+}
diff --git a/data/ages_90 b/data/ages_90
new file mode 100755
index 0000000..8449987
--- /dev/null
+++ b/data/ages_90
@@ -0,0 +1,90 @@
+1,baby
+2,baby
+3,baby
+4,baby
+5,baby
+6,baby
+7,baby
+8,baby
+9,baby
+10,child
+11,child
+12,child
+13,child
+14,child
+15,wish
+16,wish
+17,wish
+18,wish
+19,wish
+20,dude
+21,dude
+22,dude
+23,dude
+24,dude
+25,dude
+26,dude
+27,dude
+28,dude
+29,dude
+30,dude
+31,infant
+32,infant
+33,infant
+34,infant
+35,infant
+36,infant
+37,infant
+38,infant
+39,infant
+40,teenager
+41,teenager
+42,teenager
+43,teenager
+44,teenager
+45,teenager
+46,teenager
+47,teenager
+48,teenager
+49,teenager
+50,teenager
+51,newborn
+52,newborn
+53,newborn
+54,newborn
+55,newborn
+56,newborn
+57,newborn
+58,newborn
+59,newborn
+60,newborn
+61,newborn
+62,newborn
+63,newborn
+64,newborn
+65,very-young
+66,very-young
+67,very-young
+68,very-young
+69,very-young
+70,very-young
+71,very-young
+72,very-young
+73,very-young
+74,very-young
+75,very-young
+76,very-young
+77,very-young
+78,very-young
+79,very-young
+80,very-young
+81,very-young
+82,very-young
+83,very-young
+84,very-young
+85,very-young
+86,very-young
+87,very-young
+88,very-young
+89,very-young
+90,very-young
\ No newline at end of file
diff --git a/data/employee_5 b/data/employee_5
new file mode 100755
index 0000000..a0c6e81
--- /dev/null
+++ b/data/employee_5
@@ -0,0 +1,5 @@
+Anettea Belote,67,6.4,75000
+Zina Legleiter,45,6.3,150000
+Rena Broadus,68,5.9,250000
+Lorriane Shimmin,49,6.6,400000
+Elvira Binns,36,5.6,200000
\ No newline at end of file
diff --git a/data/employee_50 b/data/employee_50
new file mode 100755
index 0000000..ea60a88
--- /dev/null
+++ b/data/employee_50
@@ -0,0 +1,50 @@
+Anettea Belote,67,6.4,98784
+Zina Legleiter,45,6.3,76608
+Rena Broadus,68,5.9,174384
+Lorriane Shimmin,49,6.6,244944
+Elvira Binns,36,5.6,136080
+Zandra Laverty,47,5.8,174384
+Kira Chand,56,6.2,163296
+Rodrick Traina,28,6.7,147168
+Argelia Dixson,34,6.6,85680
+Jacelyn Rarick,68,6.8,121968
+Jen Peguero,69,5.7,226800
+Isadora Bowers,34,5.8,211680
+Jillian Meiser,22,6.7,225792
+Faye Dudney,38,6.2,73584
+Ignacia Alverson,31,6.0,139104
+Matilde Chalmers,38,6.0,69552
+Isa Goucher,22,6.1,141120
+Tova Percival,50,7.0,61488
+Reed Bourque,70,5.6,217728
+Aida Engh,68,6.8,51408
+Rosita Granillo,28,6.5,90720
+Sheri Berthiaume,22,6.0,107856
+Rita Brow,22,5.7,222768
+Celina Reedy,68,5.9,61488
+Katie Zirkle,35,6.8,147168
+Isabella Bevil,30,5.6,145152
+Tamatha Mattox,19,7.0,243936
+Brigid Berens,40,6.1,121968
+Morris Barfield,50,7.1,243936
+Roseanne Hattaway,63,6.0,165312
+Ariane Miah,19,6.6,106848
+Lacie Leep,67,6.3,117936
+Daron Dauber,25,6.2,149184
+Les Sigmund,61,7.0,194544
+Armandina Wellner,61,6.7,190512
+Shante Luckett,35,6.4,122976
+Cory Broady,70,7.0,197568
+Cassandra Clubb,39,6.3,213696
+Adriana Liston,47,5.9,87696
+Ava Clayson,33,7.0,192528
+Dalila Gean,40,6.1,232848
+Hortensia Loiselle,56,5.9,123984
+Kiley Mcglynn,68,6.5,68544
+Yang Matas,21,5.5,120960
+Letitia Hammill,49,5.6,96768
+Evia Corp,48,6.8,181440
+Thalia Deardorff,27,6.0,81648
+Theo Sieg,27,5.8,106848
+Jake Smalley,64,5.5,171360
+Katina Wilczynsk,54,5.9,170352
\ No newline at end of file
diff --git a/data/salary_5 b/data/salary_5
new file mode 100755
index 0000000..a926aeb
--- /dev/null
+++ b/data/salary_5
@@ -0,0 +1,5 @@
+75000,good life
+150000,very good life
+200000,very very good life
+250000,very very very good life
+350000,the godfather
\ No newline at end of file
diff --git a/makefile.inc b/makefile.inc
index 2f2a009..3bb6b5d 100644
--- a/makefile.inc
+++ b/makefile.inc
@@ -2,7 +2,13 @@
 CODEROOT = ..
 
 #CC = gcc
-CC = g++
+CC = g++ -ledit
 
 #CPPFLAGS = -Wall -I$(CODEROOT) -g     # with debugging info
 CPPFLAGS = -Wall -I$(CODEROOT) -g -std=c++11  # with debugging info and the C++11 feature
+
+# Comment the following line to disable command line interface (CLI).
+CPPFLAGS = -Wall -I$(CODEROOT) -std=c++11 -ledit -DDATABASE_FOLDER=\"$(CODEROOT)/cli/\" -g # with debugging info
+
+# Uncomment the following line to compile the code without using CLI.
+#CPPFLAGS = -Wall -I$(CODEROOT) -g -std=c++0x  # with debugging info and the C++11 feature
\ No newline at end of file
diff --git a/project4_report.txt b/project4_report.txt
new file mode 100755
index 0000000..b713ba0
--- /dev/null
+++ b/project4_report.txt
@@ -0,0 +1,41 @@
+1. Basic information
+Team number (e.g., 01) : 
+#1 Student ID : 
+#1 Student Name : 
+#2 Student ID : 
+#2 Student Name : 
+OS (bit) :
+gcc version :
+
+
+2. Catalog information about Index
+- Show your catalog information about an index (tables, columns). 
+
+
+3. Block Nested Loop Join (If you have implemented this feature)
+- Describe how your block nested loop join works (especially, how you manage the given buffers.)
+
+
+4. Index Nested Loop Join (If you have implemented this feature)
+- Describe how your grace hash join works.
+
+
+5. Grace Hash Join (If you have implemented this feature)
+- Describe how your grace hash join works (especially, in-memory structure).
+
+
+6. Aggregation
+- Describe how your aggregation (basic, group-based hash) works.
+
+
+7. Implementation Detail
+- Have you added your own source file (.cc or .h)?
+
+- Have you implemented any optional features? Then, describe them here.
+
+- Other implementation details:
+
+
+6. Other (optional)
+- Freely use this section to tell us about things that are related to the project 4, but not related to the other sections (optional)
+
diff --git a/qe/makefile b/qe/makefile
new file mode 100755
index 0000000..fc7cd4a
--- /dev/null
+++ b/qe/makefile
@@ -0,0 +1,61 @@
+include ../makefile.inc
+
+all: libqe.a qetest_01 qetest_02 qetest_03 qetest_04 qetest_05 qetest_06 qetest_07 qetest_08 qetest_09 qetest_10 qetest_11 qetest_12 qetest_13 qetest_14 qetest_15 qetest_16 qetest_p00 qetest_p01 qetest_p02 qetest_p03 qetest_p04 qetest_p05 qetest_p06 qetest_p07 qetest_p08 qetest_p09 qetest_p10 qetest_p11 qetest_p12     	     
+
+# lib file dependencies
+libqe.a: libqe.a(qe.o)  # and possibly other .o files
+
+# c file dependencies
+qe.o: qe.h
+
+qetest.o: qe.h
+
+# binary dependencies
+qetest_01: qetest_01.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_02: qetest_02.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_03: qetest_03.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_04: qetest_04.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_05: qetest_05.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_06: qetest_06.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_07: qetest_07.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_08: qetest_08.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_09: qetest_09.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_10: qetest_10.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_11: qetest_11.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_12: qetest_12.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_13: qetest_13.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_14: qetest_14.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_15: qetest_15.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_16: qetest_16.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_p00: qetest_p00.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_p01: qetest_p01.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_p02: qetest_p02.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_p03: qetest_p03.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_p04: qetest_p04.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_p05: qetest_p05.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_p06: qetest_p06.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_p07: qetest_p07.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_p08: qetest_p08.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_p09: qetest_p09.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_p10: qetest_p10.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_p11: qetest_p11.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+qetest_p12: qetest_p12.o libqe.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rm/librm.a $(CODEROOT)/rbf/librbf.a
+
+# dependencies to compile used libraries
+.PHONY: $(CODEROOT)/rbf/librbf.a
+$(CODEROOT)/rbf/librbf.a:
+	$(MAKE) -C $(CODEROOT)/rbf librbf.a
+
+.PHONY: $(CODEROOT)/rm/librm.a
+$(CODEROOT)/rm/librm.a:
+	$(MAKE) -C $(CODEROOT)/rm librm.a
+
+.PHONY: $(CODEROOT)/ix/libix.a
+$(CODEROOT)/ix/libix.a:
+	$(MAKE) -C $(CODEROOT)/ix libix.a
+
+.PHONY: clean
+clean:
+	-rm qetest_01 qetest_02 qetest_03 qetest_04 qetest_05 qetest_06 qetest_07 qetest_08 qetest_09 qetest_10 qetest_11 qetest_12 qetest_13 qetest_14 qetest_15 qetest_16 qetest_p00 qetest_p01 qetest_p02 qetest_p03 qetest_p04 qetest_p05 qetest_p06 qetest_p07 qetest_p08 qetest_p09 qetest_p10 qetest_p11 qetest_p12 *.a *.o *~ Tables* Columns* Index* left* right* large* group*
+	$(MAKE) -C $(CODEROOT)/rm clean
+	$(MAKE) -C $(CODEROOT)/ix clean 
diff --git a/qe/qe.cc b/qe/qe.cc
new file mode 100755
index 0000000..9184416
--- /dev/null
+++ b/qe/qe.cc
@@ -0,0 +1,7 @@
+
+#include "qe.h"
+
+Filter::Filter(Iterator *input, const Condition &condition) {
+}
+
+// ... the rest of your implementations go here
diff --git a/qe/qe.h b/qe/qe.h
new file mode 100755
index 0000000..22686b9
--- /dev/null
+++ b/qe/qe.h
@@ -0,0 +1,275 @@
+#ifndef _qe_h_
+#define _qe_h_
+
+#include "../rbf/rbfm.h"
+#include "../rm/rm.h"
+#include "../ix/ix.h"
+
+#define QE_EOF (-1)  // end of the index scan
+
+typedef enum {
+    MIN = 0, MAX, COUNT, SUM, AVG
+} AggregateOp;
+
+// The following functions use the following
+// format for the passed data.
+//    For INT and REAL: use 4 bytes
+//    For VARCHAR: use 4 bytes for the length followed by the characters
+
+struct Value {
+    AttrType type;          // type of value
+    void *data;             // value
+};
+
+struct Condition {
+    std::string lhsAttr;        // left-hand side attribute
+    CompOp op;                  // comparison operator
+    bool bRhsIsAttr;            // TRUE if right-hand side is an attribute and not a value; FALSE, otherwise.
+    std::string rhsAttr;        // right-hand side attribute if bRhsIsAttr = TRUE
+    Value rhsValue;             // right-hand side value if bRhsIsAttr = FALSE
+};
+
+class Iterator {
+    // All the relational operators and access methods are iterators.
+public:
+    virtual RC getNextTuple(void *data) = 0;
+
+    virtual void getAttributes(std::vector<Attribute> &attrs) const = 0;
+
+    virtual ~Iterator() = default;
+};
+
+class TableScan : public Iterator {
+    // A wrapper inheriting Iterator over RM_ScanIterator
+public:
+    RelationManager &rm;
+    RM_ScanIterator *iter;
+    std::string tableName;
+    std::vector<Attribute> attrs;
+    std::vector<std::string> attrNames;
+    RID rid{};
+
+    TableScan(RelationManager &rm, const std::string &tableName, const char *alias = NULL) : rm(rm) {
+        //Set members
+        this->tableName = tableName;
+
+        // Get Attributes from RM
+        rm.getAttributes(tableName, attrs);
+
+        // Get Attribute Names from RM
+        for (Attribute &attr : attrs) {
+            // convert to char *
+            attrNames.push_back(attr.name);
+        }
+
+        // Call RM scan to get an iterator
+        iter = new RM_ScanIterator();
+        rm.scan(tableName, "", NO_OP, NULL, attrNames, *iter);
+
+        // Set alias
+        if (alias) this->tableName = alias;
+    };
+
+    // Start a new iterator given the new compOp and value
+    void setIterator() {
+        iter->close();
+        delete iter;
+        iter = new RM_ScanIterator();
+        rm.scan(tableName, "", NO_OP, NULL, attrNames, *iter);
+    };
+
+    RC getNextTuple(void *data) override {
+        return iter->getNextTuple(rid, data);
+    };
+
+    void getAttributes(std::vector<Attribute> &attributes) const override {
+        attributes.clear();
+        attributes = this->attrs;
+
+        // For attribute in std::vector<Attribute>, name it as rel.attr
+        for (Attribute &attribute : attributes) {
+            std::string tmp = tableName;
+            tmp += ".";
+            tmp += attribute.name;
+            attribute.name = tmp;
+        }
+    };
+
+    ~TableScan() override {
+        iter->close();
+    };
+};
+
+class IndexScan : public Iterator {
+    // A wrapper inheriting Iterator over IX_IndexScan
+public:
+    RelationManager &rm;
+    RM_IndexScanIterator *iter;
+    std::string tableName;
+    std::string attrName;
+    std::vector<Attribute> attrs;
+    char key[PAGE_SIZE]{};
+    RID rid{};
+
+    IndexScan(RelationManager &rm, const std::string &tableName, const std::string &attrName, const char *alias = NULL)
+            : rm(rm) {
+        // Set members
+        this->tableName = tableName;
+        this->attrName = attrName;
+
+
+        // Get Attributes from RM
+        rm.getAttributes(tableName, attrs);
+
+        // Call rm indexScan to get iterator
+        iter = new RM_IndexScanIterator();
+        rm.indexScan(tableName, attrName, NULL, NULL, true, true, *iter);
+
+        // Set alias
+        if (alias) this->tableName = alias;
+    };
+
+    // Start a new iterator given the new key range
+    void setIterator(void *lowKey, void *highKey, bool lowKeyInclusive, bool highKeyInclusive) {
+        iter->close();
+        delete iter;
+        iter = new RM_IndexScanIterator();
+        rm.indexScan(tableName, attrName, lowKey, highKey, lowKeyInclusive, highKeyInclusive, *iter);
+    };
+
+    RC getNextTuple(void *data) override {
+        int rc = iter->getNextEntry(rid, key);
+        if (rc == 0) {
+            rc = rm.readTuple(tableName, rid, data);
+        }
+        return rc;
+    };
+
+    void getAttributes(std::vector<Attribute> &attributes) const override {
+        attributes.clear();
+        attributes = this->attrs;
+
+
+        // For attribute in std::vector<Attribute>, name it as rel.attr
+        for (Attribute &attribute : attributes) {
+            std::string tmp = tableName;
+            tmp += ".";
+            tmp += attribute.name;
+            attribute.name = tmp;
+        }
+    };
+
+    ~IndexScan() override {
+        iter->close();
+    };
+};
+
+class Filter : public Iterator {
+    // Filter operator
+public:
+    Filter(Iterator *input,               // Iterator of input R
+           const Condition &condition     // Selection condition
+    );
+
+    ~Filter() override = default;
+
+    RC getNextTuple(void *data) override { return QE_EOF; };
+
+    // For attribute in std::vector<Attribute>, name it as rel.attr
+    void getAttributes(std::vector<Attribute> &attrs) const override {};
+};
+
+class Project : public Iterator {
+    // Projection operator
+public:
+    Project(Iterator *input,                    // Iterator of input R
+            const std::vector<std::string> &attrNames) {};   // std::vector containing attribute names
+    ~Project() override = default;
+
+    RC getNextTuple(void *data) override { return QE_EOF; };
+
+    // For attribute in std::vector<Attribute>, name it as rel.attr
+    void getAttributes(std::vector<Attribute> &attrs) const override {};
+};
+
+class BNLJoin : public Iterator {
+    // Block nested-loop join operator
+public:
+    BNLJoin(Iterator *leftIn,            // Iterator of input R
+            TableScan *rightIn,           // TableScan Iterator of input S
+            const Condition &condition,   // Join condition
+            const unsigned numPages       // # of pages that can be loaded into memory,
+            //   i.e., memory block size (decided by the optimizer)
+    ) {};
+
+    ~BNLJoin() override = default;;
+
+    RC getNextTuple(void *data) override { return QE_EOF; };
+
+    // For attribute in std::vector<Attribute>, name it as rel.attr
+    void getAttributes(std::vector<Attribute> &attrs) const override {};
+};
+
+class INLJoin : public Iterator {
+    // Index nested-loop join operator
+public:
+    INLJoin(Iterator *leftIn,           // Iterator of input R
+            IndexScan *rightIn,          // IndexScan Iterator of input S
+            const Condition &condition   // Join condition
+    ) {};
+
+    ~INLJoin() override = default;
+
+    RC getNextTuple(void *data) override { return QE_EOF; };
+
+    // For attribute in std::vector<Attribute>, name it as rel.attr
+    void getAttributes(std::vector<Attribute> &attrs) const override {};
+};
+
+// Optional for everyone. 10 extra-credit points
+class GHJoin : public Iterator {
+    // Grace hash join operator
+public:
+    GHJoin(Iterator *leftIn,               // Iterator of input R
+           Iterator *rightIn,               // Iterator of input S
+           const Condition &condition,      // Join condition (CompOp is always EQ)
+           const unsigned numPartitions     // # of partitions for each relation (decided by the optimizer)
+    ) {};
+
+    ~GHJoin() override = default;
+
+    RC getNextTuple(void *data) override { return QE_EOF; };
+
+    // For attribute in std::vector<Attribute>, name it as rel.attr
+    void getAttributes(std::vector<Attribute> &attrs) const override {};
+};
+
+class Aggregate : public Iterator {
+    // Aggregation operator
+public:
+    // Mandatory
+    // Basic aggregation
+    Aggregate(Iterator *input,          // Iterator of input R
+              const Attribute &aggAttr,        // The attribute over which we are computing an aggregate
+              AggregateOp op            // Aggregate operation
+    ) {};
+
+    // Optional for everyone: 5 extra-credit points
+    // Group-based hash aggregation
+    Aggregate(Iterator *input,             // Iterator of input R
+              const Attribute &aggAttr,           // The attribute over which we are computing an aggregate
+              const Attribute &groupAttr,         // The attribute over which we are grouping the tuples
+              AggregateOp op              // Aggregate operation
+    ) {};
+
+    ~Aggregate() override = default;
+
+    RC getNextTuple(void *data) override { return QE_EOF; };
+
+    // Please name the output attribute as aggregateOp(aggAttr)
+    // E.g. Relation=rel, attribute=attr, aggregateOp=MAX
+    // output attrname = "MAX(rel.attr)"
+    void getAttributes(std::vector<Attribute> &attrs) const override {};
+};
+
+#endif
diff --git a/qe/qe_test_util.h b/qe/qe_test_util.h
new file mode 100755
index 0000000..b615907
--- /dev/null
+++ b/qe/qe_test_util.h
@@ -0,0 +1,1119 @@
+#ifndef _qetest_util_h_
+#define _qetest_util_h_
+
+#ifndef _fail_
+#define _fail_
+const int fail = -1;
+#endif
+
+#include <fstream>
+#include <iostream>
+
+#include <vector>
+
+#include <cstdlib>
+#include <cstdio>
+#include <cstring>
+
+#include "qe.h"
+#include "../rm/rm_test_util.h"
+
+// Global Initialization
+// RelationManager *rm = RelationManager::instance();
+IndexManager &im = IndexManager::instance();
+
+// Number of tuples in each relation
+const int tupleCount = 100;
+
+// Number of tuples in left large relation
+const int varcharTupleCount = 1000;
+
+// Number of tuples in large relation
+const int largeTupleCount = 50000;
+
+// Buffer size and character buffer size
+const unsigned bufSize = 200;
+
+int createLeftTable() {
+    // Functions Tested;
+    // 1. Create Table
+    cerr << endl << "****Create Left Table****" << endl;
+
+    vector<Attribute> attrs;
+
+    Attribute attr;
+    attr.name = "A";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "B";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "C";
+    attr.type = TypeReal;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    RC rc = rm.createTable("left", attrs);
+    if (rc == success) {
+        cerr << "****Left Table Created!****" << endl;
+    }
+    return rc;
+}
+
+int createLeftTable2() {
+    // Functions Tested;
+    // 1. Create Table
+    cerr << endl << "****Create Left2 Table****" << endl;
+
+    vector<Attribute> attrs;
+
+    Attribute attr;
+    attr.name = "A";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "B";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "C";
+    attr.type = TypeReal;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    RC rc = rm.createTable("left2", attrs);
+    if (rc == success) {
+        cerr << "****Left2 Table Created!****" << endl;
+    }
+    return rc;
+}
+
+int createLeftTable3() {
+    // Functions Tested;
+    // 1. Create Table
+    cerr << endl << "****Create Left3 Table****" << endl;
+
+    vector<Attribute> attrs;
+
+    Attribute attr;
+    attr.name = "A";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "B";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "C";
+    attr.type = TypeReal;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    RC rc = rm.createTable("left3", attrs);
+    if (rc == success) {
+        cerr << "****Left3 Table Created!****" << endl;
+    }
+    return rc;
+}
+
+int createLargeLeftTable() {
+    // Functions Tested;
+    // 1. Create Table
+    cerr << endl << "****Create Large Left Table****" << endl;
+
+    vector<Attribute> attrs;
+
+    Attribute attr;
+    attr.name = "A";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "B";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "C";
+    attr.type = TypeReal;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    RC rc = rm.createTable("largeleft", attrs);
+    if (rc == success) {
+        cerr << "****Large left Table Created!****" << endl;
+    }
+    return rc;
+}
+
+int createLargeLeftTable2() {
+    // Functions Tested;
+    // 1. Create Table
+    cerr << endl << "****Create Large Left2 Table****" << endl;
+
+    vector<Attribute> attrs;
+
+    Attribute attr;
+    attr.name = "A";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "B";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "C";
+    attr.type = TypeReal;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    RC rc = rm.createTable("largeleft2", attrs);
+    if (rc == success) {
+        cerr << "****Large left2 Table Created!****" << endl;
+    }
+    return rc;
+}
+
+int createLeftVarCharTable() {
+    // Functions Tested;
+    // 1. Create Table
+    cerr << endl << "****Create Left VarChar Table****" << endl;
+
+    vector<Attribute> attrs;
+
+    Attribute attr;
+    attr.name = "A";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "B";
+    attr.type = TypeVarChar;
+    attr.length = 30;
+    attrs.push_back(attr);
+
+    RC rc = rm.createTable("leftvarchar", attrs);
+    if (rc == success) {
+        cerr << "****Left VarChar Table Created!****" << endl;
+    }
+    return rc;
+}
+
+int createRightTable() {
+    // Functions Tested;
+    // 1. Create Table
+    cerr << endl << "****Create Right Table****" << endl;
+
+    vector<Attribute> attrs;
+
+    Attribute attr;
+    attr.name = "B";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "C";
+    attr.type = TypeReal;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "D";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    RC rc = rm.createTable("right", attrs);
+    if (rc == success) {
+        cerr << "****Right Table Created!****" << endl;
+    }
+    return rc;
+}
+
+int createRightTable2() {
+    // Functions Tested;
+    // 1. Create Table
+    cerr << endl << "****Create Right2 Table****" << endl;
+
+    vector<Attribute> attrs;
+
+    Attribute attr;
+    attr.name = "B";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "C";
+    attr.type = TypeReal;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "D";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    RC rc = rm.createTable("right2", attrs);
+    if (rc == success) {
+        cerr << "****Right2 Table Created!****" << endl;
+    }
+    return rc;
+}
+
+int createLargeRightTable() {
+    // Functions Tested;
+    // 1. Create Table
+    cerr << endl << "****Create Large Right Table****" << endl;
+
+    vector<Attribute> attrs;
+
+    Attribute attr;
+    attr.name = "B";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "C";
+    attr.type = TypeReal;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "D";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    RC rc = rm.createTable("largeright", attrs);
+    if (rc == success) {
+        cerr << "****Large Right Table Created!****" << endl;
+    }
+    return rc;
+}
+
+int createLargeRightTable2() {
+    // Functions Tested;
+    // 1. Create Table
+    cerr << endl << "****Create Large Right2 Table****" << endl;
+
+    vector<Attribute> attrs;
+
+    Attribute attr;
+    attr.name = "B";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "C";
+    attr.type = TypeReal;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "D";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    RC rc = rm.createTable("largeright2", attrs);
+    if (rc == success) {
+        cerr << "****Large Right2 Table Created!****" << endl;
+    }
+    return rc;
+}
+
+int createRightVarCharTable() {
+    // Functions Tested;
+    // 1. Create Table
+    cerr << endl << "****Create Right VarChar Table****" << endl;
+
+    vector<Attribute> attrs;
+
+    Attribute attr;
+    attr.name = "B";
+    attr.type = TypeVarChar;
+    attr.length = 30;
+    attrs.push_back(attr);
+
+    attr.name = "C";
+    attr.type = TypeReal;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    RC rc = rm.createTable("rightvarchar", attrs);
+    if (rc == success) {
+        cerr << "****Right VarChar Table Created!****" << endl;
+    }
+    return rc;
+}
+
+int createGroupTable() {
+    // Functions Tested;
+    // 1. Create Table
+    cerr << endl << "****Create Group Table****" << endl;
+
+    vector<Attribute> attrs;
+
+    Attribute attr;
+    attr.name = "A";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "B";
+    attr.type = TypeInt;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    attr.name = "C";
+    attr.type = TypeReal;
+    attr.length = 4;
+    attrs.push_back(attr);
+
+    RC rc = rm.createTable("group", attrs);
+    if (rc == success) {
+        cerr << "****Group Table Created!****" << endl;
+    }
+    return rc;
+}
+
+// Prepare the tuple to left table in the format conforming to Insert/Update/ReadTuple and readAttribute
+void
+prepareLeftTuple(int attributeCount, unsigned char *nullAttributesIndicator, const int a, const int b, const float c,
+                 void *buf) {
+    int offset = 0;
+
+    // Null-indicators
+    bool nullBit;
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attributeCount);
+
+    // Null-indicator for the fields
+    memcpy((char *) buf + offset, nullAttributesIndicator, nullAttributesIndicatorActualSize);
+    offset += nullAttributesIndicatorActualSize;
+
+    // Beginning of the actual data
+    // Note that the left-most bit represents the first field. Thus, the offset is 7 from right, not 0.
+    // e.g., if a tuple consists of four attributes and they are all nulls, then the bit representation will be: [11110000]
+
+    // Is the A field not-NULL?
+    nullBit = nullAttributesIndicator[0] & ((unsigned) 1 << (unsigned) 7);
+
+    if (!nullBit) {
+        memcpy((char *) buf + offset, &a, sizeof(int));
+        offset += sizeof(int);
+    }
+
+    // Is the B field not-NULL?
+    nullBit = nullAttributesIndicator[0] & ((unsigned) 1 << (unsigned) 6);
+
+    if (!nullBit) {
+        memcpy((char *) buf + offset, &b, sizeof(int));
+        offset += sizeof(int);
+    }
+
+    // Is the C field not-NULL?
+    nullBit = nullAttributesIndicator[0] & ((unsigned) 1 << (unsigned) 5);
+
+    if (!nullBit) {
+        memcpy((char *) buf + offset, &c, sizeof(float));
+        offset += sizeof(float);
+    }
+}
+
+// Prepare the tuple to right table in the format conforming to Insert/Update/ReadTuple, readAttribute
+void prepareRightTuple(int attributeCount, unsigned char *nullAttributesIndicator, const int b, const float c,
+                       const int d, void *buf) {
+    int offset = 0;
+
+    // Null-indicators
+    bool nullBit = false;
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attributeCount);
+
+    // Null-indicator for the fields
+    memcpy((char *) buf + offset, nullAttributesIndicator, nullAttributesIndicatorActualSize);
+    offset += nullAttributesIndicatorActualSize;
+
+    // Beginning of the actual data
+    // Note that the left-most bit represents the first field. Thus, the offset is 7 from right, not 0.
+    // e.g., if a tuple consists of four attributes and they are all nulls, then the bit representation will be: [11110000]
+
+    // Is the B field not-NULL?
+    nullBit = nullAttributesIndicator[0] & ((unsigned) 1 << (unsigned) 7);
+
+    if (!nullBit) {
+        memcpy((char *) buf + offset, &b, sizeof(int));
+        offset += sizeof(int);
+    }
+
+    // Is the C field not-NULL?
+    nullBit = nullAttributesIndicator[0] & ((unsigned) 1 << (unsigned) 6);
+
+    if (!nullBit) {
+        memcpy((char *) buf + offset, &c, sizeof(float));
+        offset += sizeof(float);
+    }
+
+
+    // Is the C field not-NULL?
+    nullBit = nullAttributesIndicator[0] & ((unsigned) 1 << (unsigned) 5);
+
+    if (!nullBit) {
+        memcpy((char *) buf + offset, &d, sizeof(int));
+        offset += sizeof(int);
+    }
+
+}
+
+// Prepare the tuple to left var char table in the format conforming to Insert/Update/ReadTuple and readAttribute
+void prepareLeftVarCharTuple(int attributeCount, unsigned char *nullAttributesIndicator, int a, int length,
+                             const string b, void *buf) {
+    int offset = 0;
+
+    // Null-indicators
+    bool nullBit = false;
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attributeCount);
+
+    // Null-indicator for the fields
+    memcpy((char *) buf + offset, nullAttributesIndicator, nullAttributesIndicatorActualSize);
+    offset += nullAttributesIndicatorActualSize;
+
+    // Beginning of the actual data
+    // Note that the left-most bit represents the first field. Thus, the offset is 7 from right, not 0.
+    // e.g., if a tuple consists of four attributes and they are all nulls, then the bit representation will be: [11110000]
+
+    // Is the A field not-NULL?
+    nullBit = nullAttributesIndicator[0] & ((unsigned) 1 << (unsigned) 7);
+    if (!nullBit) {
+        memcpy((char *) buf + offset, &a, sizeof(int));
+        offset += sizeof(int);
+    }
+
+    // Is the B field not-NULL?
+    nullBit = nullAttributesIndicator[0] & ((unsigned) 1 << (unsigned) 6);
+    if (!nullBit) {
+        memcpy((char *) buf + offset, &length, sizeof(int));
+        offset += sizeof(int);
+        memcpy((char *) buf + offset, b.c_str(), length);
+        offset += length;
+    }
+
+}
+
+// Prepare the tuple to right var char table in the format conforming to Insert/Update/ReadTuple and readAttribute
+void prepareRightVarCharTuple(int attributeCount, unsigned char *nullAttributesIndicator, int length, const string &b,
+                              float c, void *buf) {
+    int offset = 0;
+
+    // Null-indicators
+    bool nullBit = false;
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attributeCount);
+
+    // Null-indicator for the fields
+    memcpy((char *) buf + offset, nullAttributesIndicator, nullAttributesIndicatorActualSize);
+    offset += nullAttributesIndicatorActualSize;
+
+    // Beginning of the actual data
+    // Note that the left-most bit represents the first field. Thus, the offset is 7 from right, not 0.
+    // e.g., if a tuple consists of four attributes and they are all nulls, then the bit representation will be: [11110000]
+
+    // Is the B field not-NULL?
+    nullBit = nullAttributesIndicator[0] & ((unsigned) 1 << (unsigned) 7);
+    if (!nullBit) {
+        memcpy((char *) buf + offset, &length, sizeof(int));
+        offset += sizeof(int);
+        memcpy((char *) buf + offset, b.c_str(), length);
+        offset += length;
+    }
+
+    // Is the C field not-NULL?
+    nullBit = nullAttributesIndicator[0] & ((unsigned) 1 << (unsigned) 6);
+    if (!nullBit) {
+        memcpy((char *) buf + offset, &c, sizeof(float));
+        offset += sizeof(float);
+    }
+
+}
+
+int populateLeftTable() {
+    // Functions Tested
+    // 1. InsertTuple
+    RC rc;
+    RID rid;
+    void *buf = malloc(bufSize);
+
+    // GetAttributes
+    vector<Attribute> attrs;
+    rc = rm.getAttributes("left", attrs);
+    assert(rc == success && "RelationManager::getAttributes() should not fail.");
+
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attrs.size());
+    auto *nullsIndicator = (unsigned char *) malloc(nullAttributesIndicatorActualSize);
+    memset(nullsIndicator, 0, nullAttributesIndicatorActualSize);
+
+    for (int i = 0; i < tupleCount; ++i) {
+        memset(buf, 0, bufSize);
+
+        // Prepare the tuple data for insertion
+        // a in [0,99], b in [10, 109], c in [50, 149.0]
+        int a = i;
+        int b = i + 10;
+        auto c = (float) (i + 50);
+        prepareLeftTuple(attrs.size(), nullsIndicator, a, b, c, buf);
+
+        rc = rm.insertTuple("left", buf, rid);
+        if (rc != success) {
+            goto clean_up;
+        }
+    }
+
+    clean_up:
+    free(buf);
+    return rc;
+}
+
+int populateLeftTable2() {
+    // Functions Tested
+    // 1. InsertTuple
+    RC rc = success;
+    RID rid;
+    void *buf = malloc(bufSize);
+
+    // GetAttributes
+    vector<Attribute> attrs;
+    rc = rm.getAttributes("left2", attrs);
+    assert(rc == success && "RelationManager::getAttributes() should not fail.");
+
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attrs.size());
+    auto *nullsIndicator = (unsigned char *) malloc(nullAttributesIndicatorActualSize);
+    memset(nullsIndicator, 0, nullAttributesIndicatorActualSize);
+
+    auto *nullsIndicator2 = (unsigned char *) malloc(nullAttributesIndicatorActualSize);
+    memset(nullsIndicator2, 0, nullAttributesIndicatorActualSize);
+    nullsIndicator2[0] = 128; // 10000000: column A - null
+
+    for (int i = 0; i < tupleCount; ++i) {
+        memset(buf, 0, bufSize);
+
+        // Prepare the tuple data for insertion
+        // a in [0,99], b in [10, 109], c in [50, 149.0]
+        int a = i;
+        int b = i + 10;
+        auto c = (float) (i + 50);
+
+        if (i % 2 == 1) {
+            prepareLeftTuple(attrs.size(), nullsIndicator2, a, b, c, buf);
+        } else {
+            prepareLeftTuple(attrs.size(), nullsIndicator, a, b, c, buf);
+        }
+
+        rc = rm.insertTuple("left2", buf, rid);
+        if (rc != success) {
+            goto clean_up;
+        }
+    }
+
+    clean_up:
+    free(buf);
+    return rc;
+}
+
+int populateLeftTable3(vector<RID> &rids) {
+    // Functions Tested
+    // 1. InsertTuple
+    RC rc;
+    RID rid;
+    void *buf = malloc(bufSize);
+
+    // GetAttributes
+    vector<Attribute> attrs;
+    rc = rm.getAttributes("left3", attrs);
+    assert(rc == success && "RelationManager::getAttributes() should not fail.");
+
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attrs.size());
+    auto *nullsIndicator = (unsigned char *) malloc(nullAttributesIndicatorActualSize);
+    memset(nullsIndicator, 0, nullAttributesIndicatorActualSize);
+
+    auto *nullsIndicator3 = (unsigned char *) malloc(nullAttributesIndicatorActualSize);
+    memset(nullsIndicator3, 0, nullAttributesIndicatorActualSize);
+    nullsIndicator3[0] = 0; // 00000000: no null fields
+
+    for (int i = 0; i < 3; ++i) {
+        memset(buf, 0, bufSize);
+
+        // Prepare the tuple data for insertion
+        // a in [0,2], b in [10, 12], c in [50.0, 52.0]
+        int a = i;
+        int b = i + 10;
+        auto c = (float) (i + 50);
+
+        prepareLeftTuple(attrs.size(), nullsIndicator3, a, b, c, buf);
+
+        rc = rm.insertTuple("left3", buf, rid);
+        rids.push_back(rid);
+        if (rc != success) {
+            goto clean_up;
+        }
+    }
+
+    clean_up:
+    free(buf);
+    return rc;
+}
+
+int updateLeftTable3(vector<RID> &rids) {
+    // Functions Tested
+    // 1. updateTuple
+    // 2. deleteTuple
+    RC rc;
+    void *buf = malloc(bufSize);
+
+    // GetAttributes
+    vector<Attribute> attrs;
+    rc = rm.getAttributes("left3", attrs);
+    assert(rc == success && "RelationManager::getAttributes() should not fail.");
+
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attrs.size());
+    auto *nullsIndicator = (unsigned char *) malloc(nullAttributesIndicatorActualSize);
+    memset(nullsIndicator, 0, nullAttributesIndicatorActualSize);
+
+    auto *nullsIndicator3 = (unsigned char *) malloc(nullAttributesIndicatorActualSize);
+    memset(nullsIndicator3, 0, nullAttributesIndicatorActualSize);
+    nullsIndicator3[0] = 0; // 00000000: no null fields
+
+
+    for (int i = 0; i < 2; ++i) {
+        memset(buf, 0, bufSize);
+
+        // Prepare the tuple data for insertion
+        // a in [100,101], b in [110, 111], c in [150.0, 151.0]
+        int a = 100 + i;
+        int b = i + 110;
+        auto c = (float) (i + 150);
+
+        prepareLeftTuple(attrs.size(), nullsIndicator3, a, b, c, buf);
+
+        rc = rm.updateTuple("left3", buf, rids[i]);
+        if (rc != success) {
+            goto clean_up;
+        }
+    }
+
+    // delete the last tuple
+    rc = rm.deleteTuple("left3", rids[2]);
+
+    clean_up:
+    free(buf);
+    return rc;
+}
+
+int populateLargeLeftTable() {
+    // Functions Tested
+    // 1. InsertTuple
+    RC rc;
+    RID rid;
+    void *buf = malloc(bufSize);
+
+    // GetAttributes
+    vector<Attribute> attrs;
+    rc = rm.getAttributes("largeleft", attrs);
+    assert(rc == success && "RelationManager::getAttributes() should not fail.");
+
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attrs.size());
+    auto *nullsIndicator = (unsigned char *) malloc(nullAttributesIndicatorActualSize);
+    memset(nullsIndicator, 0, nullAttributesIndicatorActualSize);
+
+    for (int i = 0; i < largeTupleCount; ++i) {
+        memset(buf, 0, bufSize);
+
+        // Prepare the tuple data for insertion
+        // a in [0,49999], b in [10, 50009], c in [50, 50049.0]
+        int a = i;
+        int b = i + 10;
+        auto c = (float) (i + 50);
+        prepareLeftTuple(attrs.size(), nullsIndicator, a, b, c, buf);
+
+        rc = rm.insertTuple("largeleft", buf, rid);
+        if (rc != success) {
+            goto clean_up;
+        }
+    }
+
+    clean_up:
+    free(buf);
+    return rc;
+}
+
+int populateLargeLeftTable2() {
+    // Functions Tested
+    // 1. InsertTuple
+    RC rc;
+    RID rid;
+    void *buf = malloc(bufSize);
+
+    // GetAttributes
+    vector<Attribute> attrs;
+    rc = rm.getAttributes("largeleft2", attrs);
+    assert(rc == success && "RelationManager::getAttributes() should not fail.");
+
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attrs.size());
+    auto *nullsIndicator = (unsigned char *) malloc(nullAttributesIndicatorActualSize);
+    memset(nullsIndicator, 0, nullAttributesIndicatorActualSize);
+
+    for (int i = 0; i < largeTupleCount; ++i) {
+        memset(buf, 0, bufSize);
+
+        // Prepare the tuple data for insertion
+        // a in [0,49999], b in [10, 50009], c in [50, 50049.0]
+        int a = i;
+        int b = i + 10;
+        auto c = (float) (i + 50);
+        prepareLeftTuple(attrs.size(), nullsIndicator, a, b, c, buf);
+
+        rc = rm.insertTuple("largeleft2", buf, rid);
+        if (rc != success) {
+            goto clean_up;
+        }
+    }
+
+    clean_up:
+    free(buf);
+    return rc;
+}
+
+int addRecordsToLargeLeftTable2() {
+    // Functions Tested
+    // 1. InsertTuple
+    RC rc;
+    RID rid;
+    void *buf = malloc(bufSize);
+
+    // GetAttributes
+    vector<Attribute> attrs;
+    rc = rm.getAttributes("largeleft2", attrs);
+    assert(rc == success && "RelationManager::getAttributes() should not fail.");
+
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attrs.size());
+    auto *nullsIndicator = (unsigned char *) malloc(nullAttributesIndicatorActualSize);
+    memset(nullsIndicator, 0, nullAttributesIndicatorActualSize);
+
+    for (int i = largeTupleCount * 2 - 1; i > largeTupleCount; --i) {
+        memset(buf, 0, bufSize);
+
+        // Prepare the tuple data for insertion
+        int a = i;
+        int b = i + 10;
+        auto c = (float) (i + 50);
+        prepareLeftTuple(attrs.size(), nullsIndicator, a, b, c, buf);
+
+        rc = rm.insertTuple("largeleft2", buf, rid);
+        if (rc != success) {
+            goto clean_up;
+        }
+    }
+
+    clean_up:
+    free(buf);
+    return rc;
+}
+
+int populateRightTable() {
+    // Functions Tested
+    // 1. InsertTuple
+    RC rc;
+    RID rid;
+    void *buf = malloc(bufSize);
+
+    // GetAttributes
+    vector<Attribute> attrs;
+    rc = rm.getAttributes("right", attrs);
+    assert(rc == success && "RelationManager::getAttributes() should not fail.");
+
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attrs.size());
+    auto *nullsIndicator = (unsigned char *) malloc(nullAttributesIndicatorActualSize);
+    memset(nullsIndicator, 0, nullAttributesIndicatorActualSize);
+
+    for (int i = 0; i < tupleCount; ++i) {
+        memset(buf, 0, bufSize);
+
+        // Prepare the tuple data for insertion
+        // b in [20, 119], c in [25, 124.0], d in [0, 99]
+        int b = i + 20;
+        auto c = (float) (i + 25);
+        int d = i;
+        prepareRightTuple(attrs.size(), nullsIndicator, b, c, d, buf);
+
+        rc = rm.insertTuple("right", buf, rid);
+        if (rc != success) {
+            goto clean_up;
+        }
+    }
+
+    clean_up:
+    free(buf);
+    return rc;
+}
+
+int populateLargeRightTable() {
+    // Functions Tested
+    // 1. InsertTuple
+    RC rc;
+    RID rid;
+    void *buf = malloc(bufSize);
+
+    // GetAttributes
+    vector<Attribute> attrs;
+    rc = rm.getAttributes("largeright", attrs);
+    assert(rc == success && "RelationManager::getAttributes() should not fail.");
+
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attrs.size());
+    auto *nullsIndicator = (unsigned char *) malloc(nullAttributesIndicatorActualSize);
+    memset(nullsIndicator, 0, nullAttributesIndicatorActualSize);
+
+    for (int i = 0; i < largeTupleCount; ++i) {
+        memset(buf, 0, bufSize);
+
+        // Prepare the tuple data for insertion
+        // b in [20, 50019], c in [25, 50024.0], d in [0, 49999]
+        int b = i + 20;
+        auto c = (float) (i + 25);
+        int d = i;
+        prepareRightTuple(attrs.size(), nullsIndicator, b, c, d, buf);
+
+        rc = rm.insertTuple("largeright", buf, rid);
+        if (rc != success) {
+            goto clean_up;
+        }
+    }
+
+    clean_up:
+    free(buf);
+    return rc;
+}
+
+int populateLargeRightTable2() {
+    // Functions Tested
+    // 1. InsertTuple
+    RC rc;
+    RID rid;
+    void *buf = malloc(bufSize);
+
+    // GetAttributes
+    vector<Attribute> attrs;
+    rc = rm.getAttributes("largeright2", attrs);
+    assert(rc == success && "RelationManager::getAttributes() should not fail.");
+
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attrs.size());
+    auto *nullsIndicator = (unsigned char *) malloc(nullAttributesIndicatorActualSize);
+    memset(nullsIndicator, 0, nullAttributesIndicatorActualSize);
+
+    for (int i = 0; i < largeTupleCount; ++i) {
+        memset(buf, 0, bufSize);
+
+        // Prepare the tuple data for insertion
+        // b in [20, 50019], c in [25, 50024.0], d in [0, 49999]
+        int b = i + 20;
+        auto c = (float) (i + 25);
+        int d = i;
+        prepareRightTuple(attrs.size(), nullsIndicator, b, c, d, buf);
+
+        rc = rm.insertTuple("largeright2", buf, rid);
+        if (rc != success) {
+            goto clean_up;
+        }
+    }
+
+    clean_up:
+    free(buf);
+    return rc;
+}
+
+int populateLeftVarCharTable() {
+    // Functions Tested
+    // 1. InsertTuple
+    RC rc;
+    RID rid;
+    void *buf = malloc(bufSize);
+
+    // GetAttributes
+    vector<Attribute> attrs;
+    rc = rm.getAttributes("leftvarchar", attrs);
+    assert(rc == success && "RelationManager::getAttributes() should not fail.");
+
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attrs.size());
+    auto *nullsIndicator = (unsigned char *) malloc(nullAttributesIndicatorActualSize);
+    memset(nullsIndicator, 0, nullAttributesIndicatorActualSize);
+
+    for (int i = 0; i < varcharTupleCount; ++i) {
+        memset(buf, 0, bufSize);
+
+        // Prepare the tuple data for insertion
+        int a = i + 20;
+
+        int length = (i % 26) + 1;
+        string b = string(length, '\0');
+        for (int j = 0; j < length; j++) {
+            b[j] = 96 + length;
+        }
+        prepareLeftVarCharTuple(attrs.size(), nullsIndicator, a, length, b, buf);
+
+        rc = rm.insertTuple("leftvarchar", buf, rid);
+        if (rc != success) {
+            goto clean_up;
+        }
+    }
+
+    clean_up:
+    free(buf);
+    return rc;
+}
+
+int populateRightVarCharTable() {
+    // Functions Tested
+    // 1. InsertTuple
+    RC rc;
+    RID rid;
+    void *buf = malloc(bufSize);
+
+    // GetAttributes
+    vector<Attribute> attrs;
+    rc = rm.getAttributes("rightvarchar", attrs);
+    assert(rc == success && "RelationManager::getAttributes() should not fail.");
+
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attrs.size());
+    auto *nullsIndicator = (unsigned char *) malloc(nullAttributesIndicatorActualSize);
+    memset(nullsIndicator, 0, nullAttributesIndicatorActualSize);
+
+    for (int i = 0; i < varcharTupleCount; ++i) {
+        memset(buf, 0, bufSize);
+
+        // Prepare the tuple data for insertion
+        int length = (i % 26) + 1;
+        string b = string(length, '\0');
+        for (int j = 0; j < length; j++) {
+            b[j] = 96 + length;
+        }
+
+        auto c = (float) (i + 10);
+        prepareRightVarCharTuple(attrs.size(), nullsIndicator, length, b, c, buf);
+
+        rc = rm.insertTuple("rightvarchar", buf, rid);
+        if (rc != success) {
+            goto clean_up;
+        }
+    }
+
+    clean_up:
+    free(buf);
+    return rc;
+}
+
+int populateGroupTable() {
+    // Functions Tested
+    // 1. InsertTuple
+    RC rc;
+    RID rid;
+    void *buf = malloc(bufSize);
+
+    // GetAttributes
+    vector<Attribute> attrs;
+    rc = rm.getAttributes("group", attrs);
+    assert(rc == success && "RelationManager::getAttributes() should not fail.");
+
+    int nullAttributesIndicatorActualSize = getActualByteForNullsIndicator(attrs.size());
+    auto *nullsIndicator = (unsigned char *) malloc(nullAttributesIndicatorActualSize);
+    memset(nullsIndicator, 0, nullAttributesIndicatorActualSize);
+
+    for (int i = 0; i < tupleCount; ++i) {
+        memset(buf, 0, bufSize);
+
+        // Prepare the tuple data for insertion
+        // a in repetition of [1,5], b in repetition of [1, 5], c in [50, 149.0]
+        int a = i % 5 + 1;
+        int b = i % 5 + 1;
+        auto c = (float) (i + 50);
+        prepareLeftTuple(attrs.size(), nullsIndicator, a, b, c, buf);
+
+        rc = rm.insertTuple("group", buf, rid);
+        if (rc != success) {
+            goto clean_up;
+        }
+    }
+
+    clean_up:
+    free(buf);
+    return rc;
+}
+
+int createIndexforLeftB() {
+    return rm.createIndex("left", "B");
+}
+
+int createIndexforLeftC() {
+    return rm.createIndex("left", "C");
+}
+
+int createIndexforLeftB2() {
+    return rm.createIndex("left2", "B");
+}
+
+int createIndexforLeftC2() {
+    return rm.createIndex("left2", "C");
+}
+
+int createIndexforLeftB3() {
+    return rm.createIndex("left3", "B");
+}
+
+int createIndexforLeftC3() {
+    return rm.createIndex("left3", "C");
+}
+
+int createIndexforRightB() {
+    return rm.createIndex("right", "B");
+}
+
+int createIndexforRightC() {
+    return rm.createIndex("right", "C");
+}
+
+int createIndexforLargeLeftB() {
+    return rm.createIndex("largeleft", "B");
+}
+
+int createIndexforLargeLeftB2() {
+    return rm.createIndex("largeleft2", "B");
+}
+
+int createIndexforLargeRightB() {
+    return rm.createIndex("largeright", "B");
+}
+
+int createIndexforLargeRightB2() {
+    return rm.createIndex("largeright2", "B");
+}
+
+int createIndexforGroupB() {
+    return rm.createIndex("group", "B");
+}
+
+int deleteAndCreateCatalog() {
+    // Try to delete the System Catalog.
+    // If this is the first time, it will generate an error. It's OK and we will ignore that.
+    RC rc = rm.deleteCatalog();
+
+    rc = rm.createCatalog();
+    assert (rc == success && "Creating the Catalog should not fail.");
+
+    return rc;
+}
+
+#endif
+
+
diff --git a/qe/qetest_01.cc b/qe/qetest_01.cc
new file mode 100755
index 0000000..e05f85d
--- /dev/null
+++ b/qe/qetest_01.cc
@@ -0,0 +1,60 @@
+#include "qe_test_util.h"
+
+int testCase_1() {
+    // Mandatory for all
+    // Create an Index
+    // Load Data
+    // Create an Index
+
+    RC rc;
+    std::cerr << std::endl << "***** In QE Test Case 1 *****" << std::endl;
+
+    // Create an index before inserting tuples.
+    rc = createIndexforLeftB();
+    if (rc != success) {
+        std::cerr << "***** createIndexforLeftB() failed.  *****" << std::endl;
+        return rc;
+    }
+
+    // Insert tuples.
+    rc = populateLeftTable();
+    if (rc != success) {
+        std::cerr << "***** populateLeftTable() failed.  *****" << std::endl;
+        return rc;
+    }
+
+    // Create an index after inserting tuples - should reflect the currently existing tuples.
+    rc = createIndexforLeftC();
+    if (rc != success) {
+        std::cerr << "***** createIndexforLeftC() failed.  *****" << std::endl;
+        return rc;
+    }
+    return rc;
+}
+
+int main() {
+    // Tables created: left
+    // Indexes created: left.B, left.C
+
+    // Initialize the system catalog
+    if (deleteAndCreateCatalog() != success) {
+        std::cerr << "***** deleteAndCreateCatalog() failed." << std::endl;
+        std::cerr << "***** [FAIL] QE Test Case 1 failed. *****" << std::endl;
+        return fail;
+    }
+
+    // Create the left table
+    if (createLeftTable() != success) {
+        std::cerr << "***** createLeftTable() failed." << std::endl;
+        std::cerr << "***** [FAIL] QE Test Case 1 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (testCase_1() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 1 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Test Case 1 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_02.cc b/qe/qetest_02.cc
new file mode 100755
index 0000000..543d706
--- /dev/null
+++ b/qe/qetest_02.cc
@@ -0,0 +1,51 @@
+#include "qe_test_util.h"
+
+RC testCase_2() {
+    // Mandatory for all
+    // Create an Index
+    // Load Data
+    // Create an Index
+
+    RC rc;
+    std::cerr << std::endl << "***** In QE Test Case 2 *****" << std::endl;
+
+    rc = createIndexforRightB();
+    if (rc != success) {
+        std::cerr << "***** createIndexforRightB() failed.  *****" << std::endl;
+        return rc;
+    }
+
+    rc = populateRightTable();
+    if (rc != success) {
+        std::cerr << "***** populateRightTable() failed.  *****" << std::endl;
+        return rc;
+    }
+
+    rc = createIndexforRightC();
+    if (rc != success) {
+        std::cerr << "***** createIndexforRightC() failed.  *****" << std::endl;
+        return rc;
+    }
+
+    return rc;
+}
+
+int main() {
+    // Tables created: right
+    // Indexes created: right.B, right.C
+
+    // Create the right table
+    if (createRightTable() != success) {
+        std::cerr << "***** createRightTable() failed. *****" << std::endl;
+        std::cerr << "***** [FAIL] QE Test Case 2 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (testCase_2() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 2 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Test Case 2 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_03.cc b/qe/qetest_03.cc
new file mode 100755
index 0000000..0f9db87
--- /dev/null
+++ b/qe/qetest_03.cc
@@ -0,0 +1,114 @@
+#include "qe_test_util.h"
+
+RC testCase_3() {
+    // Mandatory for all
+    // Filter -- TableScan as input, on an Integer Attribute
+    // SELECT * FROM LEFT WHERE B <= 30
+    std::cerr << std::endl << "***** In QE Test Case 3 *****" << std::endl;
+    RC rc = success;
+
+    auto *ts = new TableScan(rm, "left");
+    int compVal = 30;
+    int valueB = 0;
+
+    // Set up condition
+    Condition cond;
+    cond.lhsAttr = "left.B";
+    cond.op = LE_OP;
+    cond.bRhsIsAttr = false;
+    Value value{};
+    value.type = TypeInt;
+    value.data = malloc(bufSize);
+    *(int *) value.data = compVal;
+    cond.rhsValue = value;
+
+    int expectedResultCnt = 21;  // 10~30;
+    int actualResultCnt = 0;
+
+    // Create Filter
+    auto *filter = new Filter(ts, cond);
+
+    // Go over the data through iterator
+    void *data = malloc(bufSize);
+    bool nullBit;
+
+    int valueA = 0;
+    float valueC;
+
+    while (filter->getNextTuple(data) != QE_EOF) {
+        int offset = 0;
+        // Print left.A
+        // Null indicators should be placed in the beginning.
+
+        // Is an attribute A NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 7);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            rc = fail;
+            goto clean_up;
+        }
+        valueA = *(int *) ((char *) data + 1 + offset);
+
+        std::cerr << "left.A " << valueA;
+        offset += sizeof(int);
+
+        // Is an attribute B NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 6);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            rc = fail;
+            goto clean_up;
+        }
+
+        // Print left.B
+        valueB = *(int *) ((char *) data + 1 + offset);
+        std::cerr << "  left.B " << valueB;
+        offset += sizeof(int);
+        if (valueB > compVal) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            rc = fail;
+            goto clean_up;
+        }
+
+
+        // Is an attribute C NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 5);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            rc = fail;
+            goto clean_up;
+        }
+        valueC = *(float *) ((char *) data + 1 + offset);
+
+        // Print left.C
+        std::cerr << "  left.C " << valueC << std::endl;
+
+        memset(data, 0, bufSize);
+        actualResultCnt++;
+    }
+
+    if (expectedResultCnt != actualResultCnt) {
+        std::cerr << "***** The number of returned tuple is not correct. *****" << std::endl;
+        rc = fail;
+    }
+
+    clean_up:
+    delete filter;
+    delete ts;
+    free(value.data);
+    free(data);
+    return rc;
+}
+
+int main() {
+    // Tables created: none
+    // Indexes created: none
+
+    if (testCase_3() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 3 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Test Case 3 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_04.cc b/qe/qetest_04.cc
new file mode 100755
index 0000000..b6945e0
--- /dev/null
+++ b/qe/qetest_04.cc
@@ -0,0 +1,125 @@
+#include "qe_test_util.h"
+
+RC exitWithError(const TableScan *ts, const Value &value, const Filter *filter, void *data) {
+    delete filter;
+    delete ts;
+    free(data);
+    free(value.data);
+    return fail;
+}
+
+int testCase_4() {
+    // Mandatory for all
+    // 1. Filter -- on TypeVarChar Attribute
+    // SELECT * FROM leftvarchar where B = "llllllllllll"
+    std::cerr << std::endl << "***** In QE Test Case 4 *****" << std::endl;
+
+    RC rc = success;
+    auto *ts = new TableScan(rm, "leftvarchar");
+
+    // Set up condition
+    Condition cond;
+    cond.lhsAttr = "leftvarchar.B";
+    cond.op = EQ_OP;
+    cond.bRhsIsAttr = false;
+    Value value{};
+    value.type = TypeVarChar;
+    value.data = malloc(bufSize);
+    int length = 12;
+    *(int *) ((char *) value.data) = length;
+    for (unsigned i = 0; i < 12; ++i) {
+        *(char *) ((char *) value.data + 4 + i) = 12 + 96;
+    }
+    cond.rhsValue = value; // "llllllllllll"
+
+    // Create Filter
+    auto *filter = new Filter(ts, cond);
+
+    int expectedResultCnt = 39;
+    int actualResultCnt = 0;
+
+    // Go over the data through iterator
+    void *data = malloc(bufSize);
+    bool nullBit;
+
+    while (filter->getNextTuple(data) != QE_EOF) {
+        int offset = 0;
+
+        // Null indicators should be placed in the beginning.
+
+        // Is an attribute A NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 7);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(ts, value, filter, data);
+        }
+
+        // Print leftvarchar.A
+        std::cerr << "leftvarchar.A " << *(int *) ((char *) data + offset + 1);
+        offset += sizeof(int);
+
+        // Is an attribute B NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 6);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(ts, value, filter, data);
+        }
+
+        // Print leftvarchar.B
+        int len = *(int *) ((char *) data + offset + 1);
+        offset += 4;
+        std::cerr << "  leftvarchar.B.length " << len;
+
+        char *b = (char *) malloc(100);
+        memcpy(b, (char *) data + offset + 1, len);
+        b[len] = '\0';
+        std::cerr << "  leftvarchar.B " << b << std::endl;
+
+        memset(data, 0, bufSize);
+        actualResultCnt++;
+    }
+
+    if (expectedResultCnt != actualResultCnt) {
+        std::cerr << "***** The number of returned tuple is not correct. *****" << std::endl;
+        return exitWithError(ts, value, filter, data);
+    }
+    delete filter;
+    delete ts;
+    free(data);
+    free(value.data);
+    return rc;
+}
+
+int main() {
+    // Tables created: leftvarchar, rightvarchar
+    // Indexes created: none
+
+    // Create left/right large table, and populate the two tables
+    if (createLeftVarCharTable() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 4 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (populateLeftVarCharTable() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 4 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (createRightVarCharTable() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 4 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (populateRightVarCharTable() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 4 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (testCase_4() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 4 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Test Case 4 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_05.cc b/qe/qetest_05.cc
new file mode 100755
index 0000000..28b55dd
--- /dev/null
+++ b/qe/qetest_05.cc
@@ -0,0 +1,113 @@
+#include "qe_test_util.h"
+
+RC exitWithError(const IndexScan *is, const Value &value, const Filter *filter, void *data) {
+    delete filter;
+    delete is;
+    free(data);
+    free(value.data);
+    return fail;
+}
+
+RC testCase_5() {
+    // Mandatory for all
+    // 1. Filter -- IndexScan as input, on TypeReal attribute
+    // SELECT * FROM RIGHT WHERE C >= 110.0
+    cerr << endl << "***** In QE Test Case 5 *****" << endl;
+
+    RC rc = success;
+    auto *is = new IndexScan(rm, "right", "C");
+    float compVal = 110.0;
+    float valueC = 0;
+
+    // Set up condition
+    Condition cond;
+    cond.lhsAttr = "right.C";
+    cond.op = GE_OP;
+    cond.bRhsIsAttr = false;
+    Value value{};
+    value.type = TypeReal;
+    value.data = malloc(bufSize);
+    *(float *) value.data = compVal;
+    cond.rhsValue = value;
+
+    int expectedResultCnt = 15; // 110.00 ~ 124.00;
+    int actualResultCnt = 0;
+
+    // Create Filter
+    auto *filter = new Filter(is, cond);
+
+    // Go over the data through iterator
+    void *data = malloc(bufSize);
+
+    bool nullBit;
+
+    int valueB = 0;
+    int valueD = 0;
+
+    while (filter->getNextTuple(data) != QE_EOF) {
+        int offset = 0;
+
+        // is an attribute B NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 7);
+        if (nullBit) {
+            cerr << endl << "***** A returned value is not correct. *****" << endl;
+            return exitWithError(is, value, filter, data);
+        }
+        valueB = *(int *) ((char *) data + 1 + offset);
+
+        // Print right.B
+        cerr << "right.B " << valueB;
+        offset += sizeof(int);
+
+        // is an attribute C NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 6);
+        if (nullBit) {
+            cerr << endl << "***** A returned value is not correct. *****" << endl;
+            return exitWithError(is, value, filter, data);
+        }
+        valueC = *(float *) ((char *) data + 1 + offset);
+
+        // Print right.C
+        cerr << "  right.C " << valueC;
+        offset += sizeof(float);
+        if (valueC < compVal) {
+            return exitWithError(is, value, filter, data);
+        }
+
+        // is an attribute D NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 5);
+        if (nullBit) {
+            cerr << endl << "***** A returned value is not correct. *****" << endl;
+            return exitWithError(is, value, filter, data);
+        }
+        valueD = *(int *) ((char *) data + 1 + offset);
+
+        // Print right.D
+        cerr << "  right.D " << valueD << endl;
+
+        memset(data, 0, bufSize);
+        actualResultCnt++;
+    }
+    if (expectedResultCnt != actualResultCnt) {
+        cerr << "***** The number of returned tuple is not correct. *****" << endl;
+        return exitWithError(is, value, filter, data);
+    }
+    delete filter;
+    delete is;
+    free(data);
+    free(value.data);
+    return rc;
+}
+
+int main() {
+    // Tables created: none
+    // Indexes created: none
+
+    if (testCase_5() != success) {
+        cerr << "***** [FAIL] QE Test Case 5 failed. *****" << endl;
+        return fail;
+    } else {
+        cerr << "***** QE Test Case 5 finished. The result will be examined. *****" << endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_06.cc b/qe/qetest_06.cc
new file mode 100755
index 0000000..5664a7a
--- /dev/null
+++ b/qe/qetest_06.cc
@@ -0,0 +1,92 @@
+#include "qe_test_util.h"
+
+RC exitWithError(const TableScan *ts, const Project *project, void *data) {
+    delete project;
+    delete ts;
+    free(data);
+    return fail;
+}
+
+RC testCase_6() {
+    // Mandatory for all
+    // Project -- TableScan as input
+    // SELECT C,D FROM RIGHT
+    std::cout << std::endl << "***** In QE Test Case 6 *****" << std::endl;
+
+    RC rc = success;
+    auto *ts = new TableScan(rm, "right");
+
+    std::vector<std::string> attrNames;
+    attrNames.emplace_back("right.C");
+    attrNames.emplace_back("right.D");
+
+    int expectedResultCnt = 100;
+    int actualResultCnt = 0;
+    float valueC;
+    int valueD = 0;
+
+    // Create Projector
+    auto *project = new Project(ts, attrNames);
+
+    // Go over the data through iterator
+    void *data = malloc(bufSize);
+    bool nullBit;
+
+    while (project->getNextTuple(data) != QE_EOF) {
+        int offset = 0;
+
+        // Is an attribute C NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 7);
+        if (nullBit) {
+            std::cout << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(ts, project, data);
+        }
+        valueC = *(float *) ((char *) data + 1 + offset);
+
+        // Print right.C
+        std::cout << "right.C " << valueC;
+        offset += sizeof(float);
+
+
+        // Is an attribute D NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 6);
+        if (nullBit) {
+            std::cout << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(ts, project, data);
+        }
+
+        // Print right.D
+        valueD = *(int *) ((char *) data + 1 + offset);
+        std::cout << "  right.D " << valueD << std::endl;
+        if (valueD < 0 || valueD > 99) {
+            std::cout << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(ts, project, data);
+        }
+
+        memset(data, 0, bufSize);
+        actualResultCnt++;
+    }
+
+    if (expectedResultCnt != actualResultCnt) {
+        std::cout << "***** The number of returned tuple is not correct. *****" << std::endl;
+        rc = fail;
+    }
+
+    delete project;
+    delete ts;
+    free(data);
+    return rc;
+}
+
+int main() {
+    // Tables created: none
+    // Indexes created: none
+
+    if (testCase_6() != success) {
+        std::cout << "***** [FAIL] QE Test Case 6 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cout << "***** QE Test Case 6 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_07.cc b/qe/qetest_07.cc
new file mode 100755
index 0000000..5d09198
--- /dev/null
+++ b/qe/qetest_07.cc
@@ -0,0 +1,132 @@
+#include "qe_test_util.h"
+
+RC exitWithError(const TableScan *leftIn, const TableScan *rightIn, const BNLJoin *bnlJoin, void *data) {
+    delete bnlJoin;
+    delete leftIn;
+    delete rightIn;
+    free(data);
+    return fail;
+}
+
+RC testCase_7() {
+    // Mandatory for grad teams/solos
+    // Optional for - undergrad solo (+5 extra credit points will be given based on the results of the BNLJ related tests)
+    // 1. BNLJoin -- on TypeInt Attribute
+    // SELECT * FROM left, right where left.B = right.B
+    std::cerr << std::endl << "***** In QE Test Case 7 *****" << std::endl;
+
+    RC rc = success;
+    // Prepare the iterator and condition
+    auto leftIn = new TableScan(rm, "left");
+    auto *rightIn = new TableScan(rm, "right");
+
+    Condition cond;
+    cond.lhsAttr = "left.B";
+    cond.op = EQ_OP;
+    cond.bRhsIsAttr = true;
+    cond.rhsAttr = "right.B";
+
+    int expectedResultCnt = 90; //20~109 --> left.B: [10,109], right.B: [20,119]
+    int actualResultCnt = 0;
+    int valueB = 0;
+
+    // Create BNLJoin
+    auto *bnlJoin = new BNLJoin(leftIn, rightIn, cond, 5);
+
+    // Go over the data through iterator
+    void *data = malloc(bufSize);
+    bool nullBit;
+
+    while (bnlJoin->getNextTuple(data) != QE_EOF) {
+        int offset = 0;
+
+        // Is an attribute left.A NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 7);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, bnlJoin, data);
+        }
+        // Print left.A
+        std::cerr << "left.A " << *(int *) ((char *) data + offset + 1) << std::endl;
+        offset += sizeof(int);
+
+        // Is an attribute left.B NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 6);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, bnlJoin, data);
+        }
+        // Print left.B
+        std::cerr << "left.B " << *(int *) ((char *) data + offset + 1) << std::endl;
+        offset += sizeof(int);
+
+        // Is an attribute left.C NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 5);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, bnlJoin, data);
+        }
+        // Print left.C
+        std::cerr << "left.C " << *(float *) ((char *) data + offset + 1) << std::endl;
+        offset += sizeof(float);
+
+        // Is an attribute right.B NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 4);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, bnlJoin, data);
+        }
+        // Print right.B
+        valueB = *(int *) ((char *) data + offset + 1);
+        std::cerr << "right.B " << valueB << std::endl;
+        offset += sizeof(int);
+
+        if (valueB < 20 || valueB > 109) {
+            return exitWithError(leftIn, rightIn, bnlJoin, data);
+        }
+
+        // Is an attribute right.C NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 3);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, bnlJoin, data);
+        }
+        // Print right.C
+        std::cerr << "right.C " << *(float *) ((char *) data + offset + 1) << std::endl;
+        offset += sizeof(float);
+
+        // Is an attribute right.D NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 2);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, bnlJoin, data);
+        }
+        // Print right.D
+        std::cerr << "right.D " << *(int *) ((char *) data + offset + 1) << std::endl;
+
+        memset(data, 0, bufSize);
+        ++actualResultCnt;
+    }
+
+    if (expectedResultCnt != actualResultCnt) {
+        std::cerr << "***** The number of returned tuple is not correct. *****" << std::endl;
+        rc = fail;
+    }
+
+    delete bnlJoin;
+    delete leftIn;
+    delete rightIn;
+    free(data);
+    return rc;
+}
+
+int main() {
+
+    if (testCase_7() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 7 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Test Case 7 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_08.cc b/qe/qetest_08.cc
new file mode 100755
index 0000000..8c21261
--- /dev/null
+++ b/qe/qetest_08.cc
@@ -0,0 +1,154 @@
+#include "qe_test_util.h"
+
+RC exitWithError(const TableScan *leftIn, const TableScan *rightIn, const BNLJoin *bnlJoin, const Value &value,
+                 const Filter *filter, void *data) {
+    delete filter;
+    delete bnlJoin;
+    delete leftIn;
+    delete rightIn;
+    free(value.data);
+    free(data);
+    return fail;
+}
+
+RC testCase_8() {
+    // Mandatory for - grad teams/solos
+    // Optional for - undergrad solo (+5 extra credit points will be given based on the results of the BNLJ related tests)
+    // Functions Tested
+    // 1. BNLJoin -- on TypeInt Attribute
+    // 2. Filter -- on TypeInt Attribute
+    // SELECT * FROM left, right WHERE left.B = right.B AND right.B >= 100
+    std::cerr << std::endl << "***** In QE Test Case 8 *****" << std::endl;
+
+    RC rc = success;
+
+    // Prepare the iterator and condition
+    auto *leftIn = new TableScan(rm, "left");
+    auto *rightIn = new TableScan(rm, "right");
+
+    Condition cond_j;
+    cond_j.lhsAttr = "left.B";
+    cond_j.op = EQ_OP;
+    cond_j.bRhsIsAttr = true;
+    cond_j.rhsAttr = "right.B";
+
+    // Create NLJoin
+    auto *bnlJoin = new BNLJoin(leftIn, rightIn, cond_j, 5);
+
+    int compVal = 100;
+
+    // Create Filter
+    Condition cond_f;
+    cond_f.lhsAttr = "right.B";
+    cond_f.op = GE_OP;
+    cond_f.bRhsIsAttr = false;
+    Value value{};
+    value.type = TypeInt;
+    value.data = malloc(bufSize);
+    *(int *) value.data = compVal;
+    cond_f.rhsValue = value;
+
+    int expectedResultCnt = 10; // join result: [20,109] --> filter result [100, 109]
+    int actualResultCnt = 0;
+    int valueB = 0;
+
+    auto *filter = new Filter(bnlJoin, cond_f);
+
+    // Go over the data through iterator
+    void *data = malloc(bufSize);
+    bool nullBit;
+
+    while (filter->getNextTuple(data) != QE_EOF) {
+        int offset = 0;
+
+        // Is an attribute left.A NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 7);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, bnlJoin, value, filter, data);
+        }
+        // Print left.A
+        std::cerr << "left.A " << *(int *) ((char *) data + offset + 1) << std::endl;
+        offset += sizeof(int);
+
+        // Is an attribute left.B NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 6);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, bnlJoin, value, filter, data);
+        }
+        // Print left.B
+        valueB = *(int *) ((char *) data + offset + 1);
+        std::cerr << "left.B " << valueB << std::endl;
+        offset += sizeof(int);
+        if (valueB < 100 || valueB > 109) {
+            return exitWithError(leftIn, rightIn, bnlJoin, value, filter, data);
+        }
+
+        // Is an attribute left.C NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 5);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, bnlJoin, value, filter, data);
+        }
+        // Print left.C
+        std::cerr << "left.C " << *(float *) ((char *) data + offset + 1) << std::endl;
+        offset += sizeof(float);
+
+        // Is an attribute right.B NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 4);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, bnlJoin, value, filter, data);
+        }
+        // Print right.B
+        std::cerr << "right.B " << *(int *) ((char *) data + offset + 1) << std::endl;
+        offset += sizeof(int);
+
+        // Is an attribute right.C NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 3);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, bnlJoin, value, filter, data);
+        }
+        // Print right.C
+        std::cerr << "right.C " << *(float *) ((char *) data + offset + 1) << std::endl;
+        offset += sizeof(float);
+
+        // Is an attribute right.D NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 2);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, bnlJoin, value, filter, data);
+        }
+        // Print right.D
+        std::cerr << "right.D " << *(int *) ((char *) data + offset + 1) << std::endl;
+
+        memset(data, 0, bufSize);
+        ++actualResultCnt;
+    }
+
+    if (expectedResultCnt != actualResultCnt) {
+        std::cerr << "***** The number of returned tuple is not correct. *****" << std::endl;
+        rc = fail;
+    }
+
+    delete filter;
+    delete bnlJoin;
+    delete leftIn;
+    delete rightIn;
+    free(value.data);
+    free(data);
+    return rc;
+}
+
+int main() {
+
+    if (testCase_8() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 8 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Test Case 8 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_09.cc b/qe/qetest_09.cc
new file mode 100755
index 0000000..56abb30
--- /dev/null
+++ b/qe/qetest_09.cc
@@ -0,0 +1,132 @@
+#include "qe_test_util.h"
+
+RC exitWithError(const TableScan *leftIn, const IndexScan *rightIn, const INLJoin *inlJoin, void *data) {
+    delete inlJoin;
+    delete leftIn;
+    delete rightIn;
+    free(data);
+    return fail;
+}
+
+RC testCase_9() {
+    // Mandatory for all
+    // 1. INLJoin -- on TypeReal Attribute
+    // SELECT * from left, right WHERE left.C = right.C
+    std::cerr << std::endl << "***** In QE Test Case 9 *****" << std::endl;
+
+    RC rc = success;
+
+    // Prepare the iterator and condition
+    auto *leftIn = new TableScan(rm, "left");
+    auto *rightIn = new IndexScan(rm, "right", "C");
+
+    Condition cond;
+    cond.lhsAttr = "left.C";
+    cond.op = EQ_OP;
+    cond.bRhsIsAttr = true;
+    cond.rhsAttr = "right.C";
+
+    int expectedResultCnt = 75; // 50.0~124.0  left.C: [50.0,149.0], right.C: [25.0,124.0]
+    int actualResultCnt = 0;
+    float valueC = 0;
+
+    // Create INLJoin
+    auto *inlJoin = new INLJoin(leftIn, rightIn, cond);
+
+    // Go over the data through iterator
+    void *data = malloc(bufSize);
+    bool nullBit;
+
+    while (inlJoin->getNextTuple(data) != QE_EOF) {
+        int offset = 0;
+
+        // Is an attribute left.A NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 7);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, inlJoin, data);
+        }
+        // Print left.A
+        std::cerr << "left.A " << *(int *) ((char *) data + offset + 1);
+        offset += sizeof(int);
+
+        // Is an attribute left.B NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 6);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, inlJoin, data);
+        }
+        // Print left.B
+        std::cerr << "  left.B " << *(int *) ((char *) data + offset + 1);
+        offset += sizeof(int);
+
+        // Is an attribute left.C NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 5);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, inlJoin, data);
+        }
+        // Print left.C
+        std::cerr << "  left.C " << *(float *) ((char *) data + offset + 1);
+        offset += sizeof(float);
+
+        // Is an attribute right.B NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 4);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, inlJoin, data);
+        }
+        // Print right.B
+        std::cerr << "  right.B " << *(int *) ((char *) data + offset + 1);
+        offset += sizeof(int);
+
+        // Is an attribute right.C NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 3);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, inlJoin, data);
+        }
+        // Print right.C
+        valueC = *(float *) ((char *) data + offset + 1);
+        std::cerr << "  right.C " << valueC;
+        offset += sizeof(float);
+        if (valueC < 50.0 || valueC > 124.0) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, inlJoin, data);
+        }
+
+        // Is an attribute right.C NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 2);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, rightIn, inlJoin, data);
+        }
+        // Print right.D
+        std::cerr << "  right.D " << *(int *) ((char *) data + offset + 1) << std::endl;
+
+        memset(data, 0, bufSize);
+        actualResultCnt++;
+    }
+
+    if (expectedResultCnt != actualResultCnt) {
+        std::cerr << "***** The number of returned tuple is not correct. *****" << std::endl;
+        rc = fail;
+    }
+
+    delete inlJoin;
+    delete leftIn;
+    delete rightIn;
+    free(data);
+    return rc;
+}
+
+int main() {
+
+    if (testCase_9() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 9 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Test Case 9 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_10.cc b/qe/qetest_10.cc
new file mode 100755
index 0000000..5774b8e
--- /dev/null
+++ b/qe/qetest_10.cc
@@ -0,0 +1,150 @@
+#include "qe_test_util.h"
+
+RC exitWithError(const IndexScan *leftIn, const Value &value, const Filter *filter, const Project *project,
+                 const IndexScan *rightIn, const Iterator *join, void *data) {
+    delete join;
+    delete rightIn;
+    delete project;
+    delete filter;
+    delete leftIn;
+    free(value.data);
+    free(data);
+    return fail;
+}
+
+int testCase_10() {
+    // Mandatory for all
+    // 1. Filter
+    // 2. Project
+    // 3. INLJoin
+    // SELECT A1.A, A1.C, right.* FROM (SELECT * FROM left WHERE left.B < 75) A1, right WHERE A1.C = right.C
+    std::cerr << std::endl << "***** In QE Test Case 10 *****" << std::endl;
+
+    RC rc = success;
+    // Create Filter
+    auto *leftIn = new IndexScan(rm, "left", "B");
+
+    int compVal = 75;
+
+    Condition cond_f;
+    cond_f.lhsAttr = "left.B";
+    cond_f.op = LT_OP;
+    cond_f.bRhsIsAttr = false;
+    Value value{};
+    value.type = TypeInt;
+    value.data = malloc(bufSize);
+    *(int *) value.data = compVal;
+    cond_f.rhsValue = value;
+
+    leftIn->setIterator(NULL, value.data, true, false);
+    auto *filter = new Filter(leftIn, cond_f); //left.B: 10~74, left.C: 50.0~114.0
+
+    // Create Project
+    std::vector<std::string> attrNames = {"left.A", "left.C"};
+    auto *project = new Project(filter, attrNames);
+
+    Condition cond_j;
+    cond_j.lhsAttr = "left.C";
+    cond_j.op = EQ_OP;
+    cond_j.bRhsIsAttr = true;
+    cond_j.rhsAttr = "right.C";
+
+    // Create Join
+    IndexScan *rightIn = NULL;
+    Iterator *join = NULL;
+    rightIn = new IndexScan(rm, "right", "C");
+    join = new INLJoin(project, rightIn, cond_j);
+
+    int expectedResultCnt = 65; //50.0~114.0
+    int actualResultCnt = 0;
+    float valueC = 0;
+
+    // Go over the data through iterator
+    void *data = malloc(bufSize);
+    bool nullBit;
+
+    while (join->getNextTuple(data) != QE_EOF) {
+        int offset = 0;
+
+        // Is an attribute left.A NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 7);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, value, filter, project, rightIn, join, data);
+        }
+        // Print left.A
+        std::cerr << "left.A " << *(int *) ((char *) data + offset + 1);
+        offset += sizeof(int);
+
+        // Is an attribute left.C NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 6);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, value, filter, project, rightIn, join, data);
+        }
+        // Print left.C
+        std::cerr << "  left.C " << *(float *) ((char *) data + offset + 1);
+        offset += sizeof(float);
+
+        // Is an attribute right.B NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 5);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, value, filter, project, rightIn, join, data);
+        }
+        // Print right.B
+        std::cerr << "  right.B " << *(int *) ((char *) data + offset + 1);
+        offset += sizeof(int);
+
+        // Is an attribute right.C NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 4);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, value, filter, project, rightIn, join, data);
+        }
+        // Print right.C
+        valueC = *(float *) ((char *) data + offset + 1);
+        std::cerr << "  right.C " << valueC;
+        offset += sizeof(float);
+        if (valueC < 50.0 || valueC > 114.0) {
+            return exitWithError(leftIn, value, filter, project, rightIn, join, data);
+        }
+
+        // Is an attribute right.D NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 3);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            return exitWithError(leftIn, value, filter, project, rightIn, join, data);
+        }
+        // Print right.D
+        std::cerr << "  right.D " << *(int *) ((char *) data + offset + 1);
+
+        memset(data, 0, bufSize);
+        actualResultCnt++;
+    }
+
+    if (expectedResultCnt != actualResultCnt) {
+        std::cerr << "***** The number of returned tuple is not correct. *****" << std::endl;
+        rc = fail;
+    }
+
+    delete join;
+    delete rightIn;
+    delete project;
+    delete filter;
+    delete leftIn;
+    free(value.data);
+    free(data);
+    return rc;
+}
+
+int main() {
+
+    if (testCase_10() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 10 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Test Case 10 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_11.cc b/qe/qetest_11.cc
new file mode 100755
index 0000000..98cc8de
--- /dev/null
+++ b/qe/qetest_11.cc
@@ -0,0 +1,162 @@
+#include "qe_test_util.h"
+
+RC exitWithError(const TableScan *leftIn, const TableScan *rightIn, const GHJoin *ghJoin, void *data) {
+    delete ghJoin;
+    delete leftIn;
+    delete rightIn;
+    free(data);
+    return fail;
+}
+
+RC testCase_11() {
+    // Optional for all: +10 extra credit points will be given based on the results of the GHJ related tests.
+    // 1. GHJoin -- on TypeReal Attribute
+    // SELECT * from largeleft, largeright WHERE largeleft.C = largeright.C
+    std::cerr << std::endl << "***** In QE Test Case 11 *****" << std::endl;
+
+    RC rc = success;
+
+    // Prepare the iterator and condition
+    auto *leftIn = new TableScan(rm, "largeleft");
+    auto *rightIn = new TableScan(rm, "largeright");
+
+    Condition cond;
+    cond.lhsAttr = "largeleft.C";
+    cond.op = EQ_OP;
+    cond.bRhsIsAttr = true;
+    cond.rhsAttr = "largeright.C";
+
+    int expectedResultCnt = 49975; // 50.0~50024.0  left.C: [50.0,50049.0], right.C: [25.0,50024.0]
+    int actualResultCnt = 0;
+    float valueC = 0;
+    int numPartitons = 10;
+
+    // Create GHJoin
+    auto *ghJoin = new GHJoin(leftIn, rightIn, cond, numPartitons);
+
+    // Go over the data through iterator
+    void *data = malloc(bufSize);
+    bool nullBit;
+
+    while (ghJoin->getNextTuple(data) != QE_EOF) {
+
+        // At this point, partitions should be on disk.
+
+        if (actualResultCnt % 5000 == 0) {
+            std::cerr << "Processing " << actualResultCnt << " of " << largeTupleCount << " tuples." << std::endl;
+            int offset = 0;
+            // Is an attribute left.A NULL?
+            nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 7);
+            if (nullBit) {
+                std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+                return exitWithError(leftIn, rightIn, ghJoin, data);
+            }
+            // Print left.A
+            std::cerr << "largeleft.A " << *(int *) ((char *) data + offset + 1);
+            offset += sizeof(int);
+
+            // Is an attribute left.B NULL?
+            nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 6);
+            if (nullBit) {
+                std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+                return exitWithError(leftIn, rightIn, ghJoin, data);
+            }
+            // Print left.B
+            std::cerr << "  largeleft.B " << *(int *) ((char *) data + offset + 1);
+            offset += sizeof(int);
+
+            // Is an attribute left.C NULL?
+            nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 5);
+            if (nullBit) {
+                std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+                return exitWithError(leftIn, rightIn, ghJoin, data);
+            }
+            // Print left.C
+            std::cerr << "  largeleft.C " << *(float *) ((char *) data + offset + 1);
+            offset += sizeof(float);
+
+            // Is an attribute right.B NULL?
+            nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 5);
+            if (nullBit) {
+                std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+                return exitWithError(leftIn, rightIn, ghJoin, data);
+            }
+            // Print right.B
+            std::cerr << "  largeright.B " << *(int *) ((char *) data + offset + 1);
+            offset += sizeof(int);
+
+            // Is an attribute right.C NULL?
+            nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 4);
+            if (nullBit) {
+                std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+                return exitWithError(leftIn, rightIn, ghJoin, data);
+            }
+            // Print right.C
+            valueC = *(float *) ((char *) data + offset + 1);
+            std::cerr << "  largeright.C " << valueC;
+            offset += sizeof(float);
+            if (valueC < 50.0 || valueC > 50024.0) {
+                std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+                return exitWithError(leftIn, rightIn, ghJoin, data);
+            }
+
+            // Is an attribute right.D NULL?
+            nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 3);
+            if (nullBit) {
+                std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+                return exitWithError(leftIn, rightIn, ghJoin, data);
+            }
+            // Print right.D
+            std::cerr << "  largeright.D " << *(int *) ((char *) data + offset + 1) << std::endl;
+        }
+
+        memset(data, 0, bufSize);
+        actualResultCnt++;
+
+    }
+
+    if (expectedResultCnt != actualResultCnt) {
+        std::cerr << "***** The number of returned tuple is not correct. *****" << std::endl;
+        rc = fail;
+    }
+
+    delete ghJoin;
+    delete leftIn;
+    delete rightIn;
+    free(data);
+    return rc;
+}
+
+int main() {
+    // Tables created: largeleft, largeright
+    // Indexes created: none
+
+    // Create left/right large table, and populate the table
+    if (createLargeLeftTable() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 11 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (populateLargeLeftTable() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 11 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (createLargeRightTable() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 11 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (populateLargeRightTable() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 11 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (testCase_11() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 11 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Test Case 11 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_12.cc b/qe/qetest_12.cc
new file mode 100755
index 0000000..6edc509
--- /dev/null
+++ b/qe/qetest_12.cc
@@ -0,0 +1,142 @@
+#include "qe_test_util.h"
+
+RC exitWithError(const TableScan *leftIn, const TableScan *rightIn, const GHJoin *ghJoin, void *data) {
+    delete ghJoin;
+    delete leftIn;
+    delete rightIn;
+    free(data);
+    return fail;
+}
+
+RC testCase_12() {
+    // Optional for all: +10 extra credit points will be given based on the results of the GHJ related tests.
+    // 1. GHJoin -- on TypeReal Attribute
+    // SELECT * from largeleft, largeright WHERE largeleft.C = largeright.C
+    std::cerr << std::endl << "***** In QE Test Case 12 *****" << std::endl;
+
+    RC rc = success;
+
+    // Prepare the iterator and condition
+    auto *leftIn = new TableScan(rm, "largeleft");
+    auto *rightIn = new TableScan(rm, "largeright");
+
+    Condition cond;
+    cond.lhsAttr = "largeleft.C";
+    cond.op = EQ_OP;
+    cond.bRhsIsAttr = true;
+    cond.rhsAttr = "largeright.C";
+
+    // int expectedResultCnt = 49975; // 50.0~50024.0  left.C: [50.0,50049.0], right.C: [25.0,50024.0]
+    int actualResultCnt = 0;
+    float valueC = 0;
+    int numPartitons = 10;
+
+    // Create GHJoin
+    auto *ghJoin = new GHJoin(leftIn, rightIn, cond, numPartitons);
+
+    // Go over the data through iterator
+    void *data = malloc(bufSize);
+    bool nullBit;
+
+    while (ghJoin->getNextTuple(data) != QE_EOF) {
+
+        // At this point, partitions should be on disk.
+
+        if (actualResultCnt % 5000 == 0) {
+            std::cerr << "Processing " << actualResultCnt << " of " << largeTupleCount << " tuples." << std::endl;
+            int offset = 0;
+            // Is an attribute left.A NULL?
+            nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 7);
+            if (nullBit) {
+                std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+                return exitWithError(leftIn, rightIn, ghJoin, data);
+            }
+            // Print left.A
+            std::cerr << "largeleft.A " << *(int *) ((char *) data + offset + 1);
+            offset += sizeof(int);
+
+            // Is an attribute left.B NULL?
+            nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 6);
+            if (nullBit) {
+                std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+                return exitWithError(leftIn, rightIn, ghJoin, data);
+            }
+            // Print left.B
+            std::cerr << "  largeleft.B " << *(int *) ((char *) data + offset + 1);
+            offset += sizeof(int);
+
+            // Is an attribute left.C NULL?
+            nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 5);
+            if (nullBit) {
+                std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+                return exitWithError(leftIn, rightIn, ghJoin, data);
+            }
+            // Print left.C
+            std::cerr << "  largeleft.C " << *(float *) ((char *) data + offset + 1);
+            offset += sizeof(float);
+
+            // Is an attribute right.B NULL?
+            nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 5);
+            if (nullBit) {
+                std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+                return exitWithError(leftIn, rightIn, ghJoin, data);
+            }
+            // Print right.B
+            std::cerr << "  largeright.B " << *(int *) ((char *) data + offset + 1);
+            offset += sizeof(int);
+
+            // Is an attribute right.C NULL?
+            nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 4);
+            if (nullBit) {
+                std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+                return exitWithError(leftIn, rightIn, ghJoin, data);
+            }
+            // Print right.C
+            valueC = *(float *) ((char *) data + offset + 1);
+            std::cerr << "  largeright.C " << valueC;
+            offset += sizeof(float);
+            if (valueC < 50.0 || valueC > 50024.0) {
+                std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+                return exitWithError(leftIn, rightIn, ghJoin, data);
+            }
+
+            // Is an attribute right.D NULL?
+            nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 3);
+            if (nullBit) {
+                std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+                return exitWithError(leftIn, rightIn, ghJoin, data);
+            }
+            // Print right.D
+            std::cerr << "  largeright.D " << *(int *) ((char *) data + offset + 1) << std::endl;
+        }
+
+        memset(data, 0, bufSize);
+        actualResultCnt++;
+
+        if (actualResultCnt == 10000) {
+            std::cerr << std::endl
+                      << "***** Stopping the join process on purpose. The contents in the directory will be checked. *****"
+                      << std::endl;
+            break;
+        }
+    }
+
+    delete ghJoin;
+    delete leftIn;
+    delete rightIn;
+    free(data);
+    return rc;
+}
+
+int main() {
+
+    if (testCase_12() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 12 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr
+                << "***** QE Test Case 12 finished. The result and the contents in the directory will be examined. *****"
+                << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_13.cc b/qe/qetest_13.cc
new file mode 100755
index 0000000..78a4861
--- /dev/null
+++ b/qe/qetest_13.cc
@@ -0,0 +1,60 @@
+#include "qe_test_util.h"
+
+RC testCase_13() {
+    // Mandatory for the grad teams/solos
+    // Optional for undergrad solos: +5 extra credit points will be given based on the results of the basic aggregation related tests
+    // 1. Basic aggregation - max
+    // SELECT max(left.B) from left
+    std::cerr << "***** In QE Test Case 13 *****" << std::endl;
+
+    RC rc = success;
+
+    // Create TableScan
+    auto *input = new TableScan(rm, "left");
+
+    // Create Aggregate
+    Attribute aggAttr;
+    aggAttr.name = "left.B";
+    aggAttr.type = TypeInt;
+    aggAttr.length = 4;
+    auto *agg = new Aggregate(input, aggAttr, MAX);
+
+    int count = 0;
+    void *data = malloc(bufSize);
+
+    // An aggregation returns a float value
+    float maxVal = 0.0;
+
+    while (agg->getNextTuple(data) != QE_EOF) {
+        maxVal = *(float *) ((char *) data + 1);
+        std::cerr << "MAX(left.B) " << maxVal << std::endl;
+        memset(data, 0, sizeof(int));
+        count++;
+        if (count > 1) {
+            std::cerr << "***** The number of returned tuple is not correct. *****" << std::endl;
+            rc = fail;
+            break;
+        }
+    }
+
+    if (maxVal != 109.0) {
+        rc = fail;
+    }
+
+    delete agg;
+    delete input;
+    free(data);
+    return rc;
+
+}
+
+int main() {
+
+    if (testCase_13() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 13 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Test Case 13 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_14.cc b/qe/qetest_14.cc
new file mode 100755
index 0000000..cdd7ebe
--- /dev/null
+++ b/qe/qetest_14.cc
@@ -0,0 +1,58 @@
+#include "qe_test_util.h"
+
+RC testCase_14() {
+    // Mandatory for the grad teams/solos
+    // Optional for the undergrad solos: +5 extra credit points will be given based on the results of the basic aggregation related tests.
+    // 1. Basic aggregation - AVG
+    // SELECT AVG(right.B) from left
+
+    std::cerr << "***** In QE Test Case 14 *****" << std::endl;
+
+    // Create TableScan
+    auto *input = new TableScan(rm, "right");
+
+    RC rc = success;
+
+    // Create Aggregate
+    Attribute aggAttr;
+    aggAttr.name = "right.B";
+    aggAttr.type = TypeInt;
+    aggAttr.length = 4;
+    auto *agg = new Aggregate(input, aggAttr, AVG);
+
+    void *data = malloc(bufSize);
+    float average = 0.0;
+    int count = 0;
+
+    while (agg->getNextTuple(data) != QE_EOF) {
+        average = *(float *) ((char *) data + 1);
+        std::cerr << "AVG(right.B) " << average << std::endl;
+        memset(data, 0, sizeof(float) + 1);
+        count++;
+        if (count > 1) {
+            std::cerr << "***** The number of returned tuple is not correct. *****" << std::endl;
+            rc = fail;
+            break;
+        }
+    }
+
+    if (average != 69.5) {
+        rc = fail;
+    }
+
+    delete agg;
+    delete input;
+    free(data);
+    return rc;
+}
+
+int main() {
+
+    if (testCase_14() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 14 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Test Case 14 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_15.cc b/qe/qetest_15.cc
new file mode 100755
index 0000000..93f6847
--- /dev/null
+++ b/qe/qetest_15.cc
@@ -0,0 +1,84 @@
+#include "qe_test_util.h"
+
+RC testCase_15() {
+    // Optional for all: +5 extra credit points will be given based on the results of the group-based hash aggregation related tests.
+    // Aggregate -- MIN (with GroupBy)
+    // SELECT group.B, MIN(group.A) FROM group GROUP BY group.B
+
+    std::cerr << "***** In QE Test Case 15 *****" << std::endl;
+
+    RC rc = 0;
+    // Create TableScan
+    auto *input = new TableScan(rm, "group");
+
+    // Create Aggregate
+    Attribute aggAttr;
+    aggAttr.name = "group.A";
+    aggAttr.type = TypeInt;
+    aggAttr.length = 4;
+
+    Attribute gAttr;
+    gAttr.name = "group.B";
+    gAttr.type = TypeInt;
+    gAttr.length = 4;
+    auto *agg = new Aggregate(input, aggAttr, gAttr, MIN);
+
+    int idVal = 0;
+    float minVal = 0;
+    int expectedResultCnt = 5;
+    int actualResultCnt = 0;
+
+    void *data = malloc(bufSize);
+
+    while (agg->getNextTuple(data) != QE_EOF) {
+        int offset = 0;
+
+        // Print group.B
+        idVal = *(int *) ((char *) data + offset + 1);
+        std::cerr << "group.B " << idVal;
+        offset += sizeof(int);
+
+        // Print MIN(group.A)
+        minVal = *(float *) ((char *) data + offset + 1);
+        std::cerr << "  MIN(group.A) " << minVal << std::endl;
+
+        memset(data, 0, bufSize);
+        if (idVal != (int) minVal) {
+            std::cerr << "***** The group-based aggregation is not working properly. *****" << std::endl;
+            rc = fail;
+            break;
+        }
+        actualResultCnt++;
+    }
+
+    if (expectedResultCnt != actualResultCnt) {
+        std::cerr << "***** The number of returned tuple is not correct. *****" << std::endl;
+        rc = fail;
+    }
+
+    delete agg;
+    delete input;
+    free(data);
+    return rc;
+}
+
+int main() {
+
+    if (createGroupTable() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 15 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (populateGroupTable() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 15 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (testCase_15() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 15 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Test Case 15 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_16.cc b/qe/qetest_16.cc
new file mode 100755
index 0000000..240494d
--- /dev/null
+++ b/qe/qetest_16.cc
@@ -0,0 +1,74 @@
+#include "qe_test_util.h"
+
+RC testCase_16() {
+    // Optional for all teams: +5 extra credit points will be given based on the results of the group-based hash aggregation related tests.
+    // Aggregate -- SUM (with GroupBy)
+    // SELECT group.B, SUM(group.A) FROM group GROUP BY group.B
+
+    std::cerr << "***** In QE Test Case 16 *****" << std::endl;
+
+    RC rc = success;
+
+    // Create TableScan
+    auto *input = new TableScan(rm, "group");
+
+    // Create Aggregate
+    Attribute aggAttr;
+    aggAttr.name = "group.A";
+    aggAttr.type = TypeInt;
+    aggAttr.length = 4;
+
+    Attribute gAttr;
+    gAttr.name = "group.B";
+    gAttr.type = TypeInt;
+    gAttr.length = 4;
+    auto *agg = new Aggregate(input, aggAttr, gAttr, SUM);
+
+    int idVal = 0;
+    float sumVal = 0;
+    int expectedResultCnt = 5;
+    int actualResultCnt = 0;
+
+    void *data = malloc(bufSize);
+    while (agg->getNextTuple(data) != QE_EOF) {
+        int offset = 0;
+
+        // Print group.B
+        idVal = *(int *) ((char *) data + offset + 1);
+        std::cerr << "group.B " << idVal;
+        offset += sizeof(int);
+
+        // Print SUM(group.A)
+        sumVal = *(float *) ((char *) data + offset + 1);
+        std::cerr << "  SUM(group.A) " << sumVal << std::endl;
+
+        memset(data, 0, bufSize);
+        if ((int) sumVal != (idVal * 20)) {
+            std::cerr << "***** The group-based aggregation is not working properly. *****" << std::endl;
+            rc = fail;
+            break;
+        }
+        actualResultCnt++;
+    }
+
+    if (expectedResultCnt != actualResultCnt) {
+        std::cerr << "***** The number of returned tuple is not correct. *****" << std::endl;
+        rc = fail;
+    }
+
+    delete agg;
+    delete input;
+    free(data);
+    return rc;
+}
+
+int main() {
+
+    if (testCase_16() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 16 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Test Case 16 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_p00.cc b/qe/qetest_p00.cc
new file mode 100755
index 0000000..442cab7
--- /dev/null
+++ b/qe/qetest_p00.cc
@@ -0,0 +1,127 @@
+#include "qe_test_util.h"
+
+RC privateTestCase_0() {
+    // Function Tested
+    // Insert three records into table
+    // update two records
+    // delete the last record
+    // Table scan with filter
+    // Index scan with filter
+    // compare the results from both scans
+    std::cerr << std::endl << "***** In QE Private Test Case 0 *****" << std::endl;
+    RC rc = success;
+
+    auto *ts = new TableScan(rm, "left3");
+    int compVal = 100;
+
+    // Set up condition
+    Condition cond1;
+    cond1.lhsAttr = "left3.B";
+    cond1.op = GE_OP;
+    cond1.bRhsIsAttr = false;
+    Value value1{};
+    value1.type = TypeInt;
+    value1.data = malloc(bufSize);
+    *(int *) value1.data = compVal;
+    cond1.rhsValue = value1;
+
+    // Create Filter
+    auto *filter1 = new Filter(ts, cond1);
+
+    auto *is = new IndexScan(rm, "left3", "B");
+
+    // Set up condition
+    Condition cond2;
+    cond2.lhsAttr = "left3.B";
+    cond2.op = GE_OP;
+    cond2.bRhsIsAttr = false;
+    Value value2{};
+    value2.type = TypeInt;
+    value2.data = malloc(bufSize);
+    *(int *) value2.data = compVal;
+    cond2.rhsValue = value2;
+
+    // Create Filter
+    auto *filter2 = new Filter(is, cond2);
+
+    // Go over the data through iterator
+    char data1[bufSize];
+    char data2[bufSize];
+    memset(data1, 0, bufSize);
+    memset(data2, 0, bufSize);
+    int count = 0;
+    int tscount = 0;
+    int iscount = 0;
+
+    while (filter1->getNextTuple(data1) != QE_EOF) {
+        tscount++;
+
+        if (filter2->getNextTuple(data2) == QE_EOF) {
+            std::cerr << "***** [FAIL] The numbers of results from both scan: " << count << " " << tscount << " "
+                      << iscount << " do not match. ***** " << std::endl;
+            rc = fail;
+            break;
+        } else {
+            iscount++;
+        }
+
+        memset(data1, 0, bufSize);
+        memset(data2, 0, bufSize);
+
+        count++;
+    }
+
+    // largeleft.B >= 100 from [110-111] = 2
+    if (count != 2 || tscount != count || iscount != count) {
+        std::cerr << " ***** [FAIL] The number of result: " << count << " is not correct. ***** " << std::endl;
+        rc = fail;
+    }
+
+    delete filter1;
+    delete filter2;
+    delete ts;
+    delete is;
+    free(value1.data);
+    free(value2.data);
+    return rc;
+}
+
+int main() {
+    // Tables created: left3
+    // Indexes created: left3.B
+
+    if (createLeftTable3() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 0 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (createIndexforLeftB3() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 0 failed. *****" << std::endl;
+        return fail;
+    }
+
+    std::vector<RID> rids;
+
+    if (populateLeftTable3(rids) != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 0 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (createIndexforLeftC3() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 0 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (updateLeftTable3(rids) != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 0 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (privateTestCase_0() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 0 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Private Test Case 0 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_p01.cc b/qe/qetest_p01.cc
new file mode 100755
index 0000000..d7d5fac
--- /dev/null
+++ b/qe/qetest_p01.cc
@@ -0,0 +1,113 @@
+#include "qe_test_util.h"
+
+RC privateTestCase_1() {
+    // Function Tested
+    // Insert records into table
+    // Table scan with filter
+    // Index scan with filter
+    //compare the results from both scans
+    std::cerr << std::endl << "***** In QE Private Test Case 1 *****" << std::endl;
+    RC rc = success;
+
+    auto *ts = new TableScan(rm, "largeleft2");
+    int compVal = 9999;
+
+    // Set up condition
+    Condition cond1;
+    cond1.lhsAttr = "largeleft2.B";
+    cond1.op = LT_OP;
+    cond1.bRhsIsAttr = false;
+    Value value1{};
+    value1.type = TypeInt;
+    value1.data = malloc(bufSize);
+    *(int *) value1.data = compVal;
+    cond1.rhsValue = value1;
+
+    // Create Filter
+    auto *filter1 = new Filter(ts, cond1);
+
+    auto *is = new IndexScan(rm, "largeleft2", "B");
+
+    // Set up condition
+    Condition cond2;
+    cond2.lhsAttr = "largeleft2.B";
+    cond2.op = LT_OP;
+    cond2.bRhsIsAttr = false;
+    Value value2{};
+    value2.type = TypeInt;
+    value2.data = malloc(bufSize);
+    *(int *) value2.data = compVal;
+    cond2.rhsValue = value2;
+
+    // Create Filter
+    auto *filter2 = new Filter(is, cond2);
+
+    // Go over the data through iterator
+    char data1[bufSize];
+    char data2[bufSize];
+    memset(data1, 0, bufSize);
+    memset(data2, 0, bufSize);
+    int count = 0;
+    int tscount = 0;
+    int iscount = 0;
+
+    while (filter1->getNextTuple(data1) != QE_EOF) {
+        tscount++;
+
+        if (filter2->getNextTuple(data2) == QE_EOF) {
+            std::cerr << "***** [FAIL] The numbers of results from both scan: " << count << " " << tscount << " "
+                      << iscount << " do not match. ***** " << std::endl;
+            rc = fail;
+            break;
+        } else {
+            iscount++;
+        }
+
+        memset(data1, 0, bufSize);
+        memset(data2, 0, bufSize);
+
+        count++;
+    }
+
+    // largeleft.B < 9999 from [10-9999] = 9989
+    if (count != 9989 || tscount != count || iscount != count) {
+        std::cerr << " ***** [FAIL] The number of result: " << count << " is not correct. ***** " << std::endl;
+        rc = fail;
+    }
+
+    delete filter1;
+    delete filter2;
+    delete ts;
+    delete is;
+    free(value1.data);
+    free(value2.data);
+    return rc;
+}
+
+int main() {
+    // Tables created: largeleft2
+    // Indexes created: largeleft2.B
+
+    if (createLargeLeftTable2() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 1 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (createIndexforLargeLeftB2() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 1 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (populateLargeLeftTable2() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 1 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (privateTestCase_1() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 1 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Private Test Case 1 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_p02.cc b/qe/qetest_p02.cc
new file mode 100755
index 0000000..78e2773
--- /dev/null
+++ b/qe/qetest_p02.cc
@@ -0,0 +1,133 @@
+#include "qe_test_util.h"
+
+RC privateTestCase_2() {
+    // Function Tested
+    // Insert records into table with NULL values
+    // Table scan with filter
+    // Index scan with filter
+    // compare the results from both scans
+    std::cerr << std::endl << "***** In QE Private Test Case 2 *****" << std::endl;
+    RC rc = success;
+
+    auto *ts = new TableScan(rm, "left2");
+    int compVal = 50;
+
+    // Set up condition
+    Condition cond1;
+    cond1.lhsAttr = "left2.B";
+    cond1.op = LT_OP;
+    cond1.bRhsIsAttr = false;
+    Value value1{};
+    value1.type = TypeInt;
+    value1.data = malloc(bufSize);
+    *(int *) value1.data = compVal;
+    cond1.rhsValue = value1;
+
+    // Create Filter
+    auto *filter1 = new Filter(ts, cond1);
+
+    auto *is = new IndexScan(rm, "left2", "B");
+
+    // Set up condition
+    Condition cond2;
+    cond2.lhsAttr = "left2.B";
+    cond2.op = LT_OP;
+    cond2.bRhsIsAttr = false;
+    Value value2{};
+    value2.type = TypeInt;
+    value2.data = malloc(bufSize);
+    *(int *) value2.data = compVal;
+    cond2.rhsValue = value2;
+
+    // Create Filter
+    auto *filter2 = new Filter(is, cond2);
+
+    // Go over the data through iterator
+    char data1[bufSize];
+    char data2[bufSize];
+    int offset;
+    memset(data1, 0, bufSize);
+    memset(data2, 0, bufSize);
+    int count = 0;
+    bool nullBit1;
+    bool nullBit2;
+    int nullCount1 = 0;
+    int nullCount2 = 0;
+    int tscount = 0;
+    int iscount = 0;
+
+    while (filter1->getNextTuple(data1) != QE_EOF) {
+        tscount++;
+
+        if (filter2->getNextTuple(data2) == QE_EOF) {
+            std::cerr << " ***** [FAIL] The numbers of results: " << count << " " << tscount << " " << iscount
+                      << " from both scan do not match. ***** " << std::endl;
+            rc = fail;
+            break;
+        } else {
+            iscount++;
+        }
+
+        offset = 0; // including null indicators
+
+        // Compare field A value
+        nullBit1 = *(unsigned char *) ((char *) data1 + offset) & ((unsigned) 1 << (unsigned) 7);
+        nullBit2 = *(unsigned char *) ((char *) data2 + offset) & ((unsigned) 1 << (unsigned) 7);
+
+        if (nullBit1) {
+            nullCount1++;
+        }
+
+        if (nullBit2) {
+            nullCount2++;
+        }
+
+        memset(data1, 0, bufSize);
+        memset(data2, 0, bufSize);
+
+        count++;
+    }
+
+    // left.B [10-109] : 40
+    if (count != 40 || nullCount1 != 20 || nullCount2 != 20) {
+        std::cerr << "***** [FAIL] The number of result: " << count << " " << nullCount1 << " " << nullCount2
+                  << " is not correct. ***** " << std::endl;
+        rc = fail;
+    }
+
+    delete filter1;
+    delete filter2;
+    delete ts;
+    delete is;
+    free(value1.data);
+    free(value2.data);
+    return rc;
+}
+
+int main() {
+    // Tables created: left2
+    // Indexes created: left2.B
+
+    if (createLeftTable2() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 2 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (createIndexforLeftB2() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 2 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (populateLeftTable2() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 2 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (privateTestCase_2() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 2 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Private Test Case 2 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_p03.cc b/qe/qetest_p03.cc
new file mode 100755
index 0000000..2553cce
--- /dev/null
+++ b/qe/qetest_p03.cc
@@ -0,0 +1,116 @@
+#include "qe_test_util.h"
+
+RC privateTestCase_3() {
+    // Functions Tested
+    // Inserting more records into table
+    // Table scan with filter: largeleft2.B >= largeTupleCount * 2 - 990
+    // Index scan with filter: largeleft2.B >= largeTupleCount * 2 - 990
+    // Compare the results from both scans
+    std::cout << std::endl << "***** In QE Private Test Case 3 *****" << std::endl;
+    RC rc = success;
+
+    auto *ts = new TableScan(rm, "largeleft2");
+    int compVal = largeTupleCount * 2 - 990;
+
+    // Set up condition
+    Condition cond1;
+    cond1.lhsAttr = "largeleft2.B";
+    cond1.op = GE_OP;
+    cond1.bRhsIsAttr = false;
+    Value value1{};
+    value1.type = TypeInt;
+    value1.data = malloc(bufSize);
+    *(int *) value1.data = compVal;
+    cond1.rhsValue = value1;
+
+    // Create Filter
+    auto *filter1 = new Filter(ts, cond1);
+
+    auto *is = new IndexScan(rm, "largeleft2", "B");
+
+    // Set up condition
+    Condition cond2;
+    cond2.lhsAttr = "largeleft2.B";
+    cond2.op = GE_OP;
+    cond2.bRhsIsAttr = false;
+    Value value2{};
+    value2.type = TypeInt;
+    value2.data = malloc(bufSize);
+    *(int *) value2.data = compVal;
+    cond2.rhsValue = value2;
+
+    // Create Filter
+    auto *filter2 = new Filter(is, cond2);
+
+    // Go over the data through iterator
+    char data1[bufSize];
+    char data2[bufSize];
+    int offset;
+    int tsVal;
+    int isVal;
+    memset(data1, 0, bufSize);
+    memset(data2, 0, bufSize);
+    int count = 0;
+    int tscount = 0;
+    int iscount = 0;
+
+    while (filter1->getNextTuple(data1) != QE_EOF) {
+        tscount++;
+
+        if (filter2->getNextTuple(data2) == QE_EOF) {
+            std::cout << "***** [FAIL] The numbers of results from both scan: " << count << " " << tscount << " "
+                      << iscount << " do not match. ***** " << std::endl;
+            rc = fail;
+            break;
+        } else {
+            iscount++;
+        }
+
+        offset = 1; // including nulls-indicator
+        offset += sizeof(int); // skip the field A
+
+        //compare field B value
+        tsVal = *(int *) ((char *) data1 + offset);
+        isVal = *(int *) ((char *) data2 + offset);
+        if (tsVal < compVal || isVal < compVal) {
+            cerr << "***** [FAIL] Incorrect scan value failure: table_scan.B " << tsVal << " : index_scan.B " << isVal
+                 << " *****" << std::endl;
+            rc = fail;
+            break;
+        }
+
+        memset(data1, 0, bufSize);
+        memset(data2, 0, bufSize);
+
+        count++;
+    }
+
+    if (count != 1000) {
+        std::cout << " ***** [FAIL] The number of result: " << count << " is not correct. ***** " << std::endl;
+        rc = fail;
+    }
+
+    delete filter1;
+    delete filter2;
+    delete ts;
+    delete is;
+    free(value1.data);
+    free(value2.data);
+    return rc;
+}
+
+int main() {
+
+    if (addRecordsToLargeLeftTable2() != success) {
+        std::cout << "***** [FAIL] QE Private Test Case 3 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (privateTestCase_3() != success) {
+        std::cout << "***** [FAIL] QE Private Test Case 3 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cout << "***** QE Private Test Case 3 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_p04.cc b/qe/qetest_p04.cc
new file mode 100755
index 0000000..36db181
--- /dev/null
+++ b/qe/qetest_p04.cc
@@ -0,0 +1,129 @@
+#include "qe_test_util.h"
+
+RC privateTestCase_4() {
+    RC rc = success;
+    // Functions Tested
+    // Filter
+    // BNLJoin - optional for undergrad solo
+    std::cerr << std::endl << "***** In QE Private Test Case 4 *****" << std::endl;
+
+    // Prepare the iterator and condition
+    auto *leftIn = new TableScan(rm, "largeleft2");
+    auto *rightIn = new TableScan(rm, "largeright2");
+
+    // Set up condition
+    Condition filterCond;
+    filterCond.lhsAttr = "largeleft2.B";
+    filterCond.op = LE_OP;
+    filterCond.bRhsIsAttr = false;
+    Value value1{};
+    value1.type = TypeInt;
+    value1.data = malloc(bufSize);
+    *(int *) value1.data = 1109;
+    filterCond.rhsValue = value1;
+
+    // Create Filter
+    auto *filter = new Filter(leftIn, filterCond);
+
+    Condition joinCond;
+    joinCond.lhsAttr = "largeleft2.B";
+    joinCond.op = EQ_OP;
+    joinCond.bRhsIsAttr = true;
+    joinCond.rhsAttr = "largeright2.B";
+
+    int expectedResultCnt = 1090; //20~1109 --> largeleft2.B: [10,1109], largeright2.B: [20,50019]
+    int actualResultCnt = 0;
+    int valueB = 0;
+
+    // Create BNLJoin
+    auto *bnlJoin = new BNLJoin(filter, rightIn, joinCond, 50);
+
+    // Go over the data through iterator
+    void *data = malloc(bufSize);
+    while (bnlJoin->getNextTuple(data) != QE_EOF) {
+
+        actualResultCnt++;
+        int offset = 1; // including nulls-indicator
+
+        int la = 0;
+        int lb = 0;
+        float lc;
+        float rC;
+        int rd = 0;
+
+        // left.A
+        la = *(int *) ((char *) data + offset);
+        offset += sizeof(int);
+
+        // left.B
+        lb = *(int *) ((char *) data + offset);
+        offset += sizeof(int);
+
+        // left.C
+        lc = *(float *) ((char *) data + offset);
+        offset += sizeof(float);
+
+        // right.B
+        valueB = *(int *) ((char *) data + offset);
+        offset += sizeof(int);
+
+        // right.C
+        rC = *(float *) ((char *) data + offset);
+        offset += sizeof(float);
+
+        // right.D
+        rd = *(int *) ((char *) data + offset);
+
+        if (valueB < 20 || valueB > 1109) {
+            std::cerr << "***** [FAIL] Incorrect value: " << valueB << " returned. *****" << std::endl;
+            std::cerr << "count:" << actualResultCnt << " lA:" << la << " lB:" << lb << " lC:" << lc << " rB:" << valueB
+                      << " rC:" << rC << " rD:" << rd << std::endl;
+            rc = fail;
+            break;
+        }
+
+        memset(data, 0, bufSize);
+    }
+
+    if (expectedResultCnt != actualResultCnt) {
+        std::cerr << " ***** Expected Result Count: " << expectedResultCnt << std::endl;
+        std::cerr << " ***** [FAIL] The number of result: " << actualResultCnt << " is not correct. ***** "
+                  << std::endl;
+        rc = fail;
+    }
+
+    delete bnlJoin;
+    delete filter;
+    delete leftIn;
+    delete rightIn;
+    free(data);
+    return rc;
+}
+
+int main() {
+    // Tables created: largeright2
+    // Indexes created: largeright2.B
+
+    if (createLargeRightTable2() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 4 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (populateLargeRightTable2() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 4 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (createIndexforLargeRightB2() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 4 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (privateTestCase_4() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 4 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Private Test Case 4 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_p05.cc b/qe/qetest_p05.cc
new file mode 100755
index 0000000..c25a457
--- /dev/null
+++ b/qe/qetest_p05.cc
@@ -0,0 +1,128 @@
+#include "qe_test_util.h"
+
+RC privateTestCase_5() {
+    RC rc = success;
+    // Functions Tested
+    // Left deep block nested loop join - optional for undergrad solo
+    std::cerr << std::endl << "***** In QE Private Test Case 5 *****" << std::endl;
+
+    // Prepare the iterator and condition
+    auto *leftIn = new TableScan(rm, "largeleft2");
+    auto *rightIn1 = new TableScan(rm, "largeright2");
+    auto *rightIn2 = new TableScan(rm, "left");
+
+    // Set up condition
+    Condition filterCond;
+    filterCond.lhsAttr = "largeleft2.B";
+    filterCond.op = LE_OP;
+    filterCond.bRhsIsAttr = false;
+    Value value1{};
+    value1.type = TypeInt;
+    value1.data = malloc(bufSize);
+    *(int *) value1.data = 109;
+    filterCond.rhsValue = value1;
+
+    // Create Filter
+    auto *filter = new Filter(leftIn, filterCond);
+
+    Condition joinCond1;
+    joinCond1.lhsAttr = "largeleft2.B";
+    joinCond1.op = EQ_OP;
+    joinCond1.bRhsIsAttr = true;
+    joinCond1.rhsAttr = "largeright2.B";
+
+    // Create child NLJoin
+    auto *childBNLJoin = new BNLJoin(filter, rightIn1, joinCond1, 50);
+
+    Condition joinCond2;
+    joinCond2.lhsAttr = "largeleft2.B";
+    joinCond2.op = EQ_OP;
+    joinCond2.bRhsIsAttr = true;
+    joinCond2.rhsAttr = "left.B";
+
+    // Create top NLJoin
+    auto *bnlJoin = new BNLJoin(childBNLJoin, rightIn2, joinCond2, 50);
+
+    int expectedResultCnt = 90; //20~109 --> largeleft2.B: [10,109], largeright2.B: [20,50019], left.B: [10, 109]
+    int actualResultCnt = 0;
+    int valueB = 0;
+
+    // Go over the data through iterator
+    void *data = malloc(bufSize);
+    while (bnlJoin->getNextTuple(data) != QE_EOF) {
+        if (actualResultCnt % 10 == 0) {
+            int offset = 2; //including nulls-indicator
+
+            // Print largeLeft.A
+            std::cerr << "largeleft2.A " << *(int *) ((char *) data + offset);
+            offset += sizeof(int);
+
+            // Print largeLeft.B
+            std::cerr << " B " << *(int *) ((char *) data + offset);
+            offset += sizeof(int);
+
+            // Print largeLeft.C
+            std::cerr << " C " << *(float *) ((char *) data + offset);
+            offset += sizeof(float);
+
+            // Print largeLeft.B
+            valueB = *(int *) ((char *) data + offset);
+            std::cerr << " largeright2.B " << valueB;
+            offset += sizeof(int);
+
+            if (valueB < 20 || valueB > 109) {
+                std::cerr << std::endl << "***** [FAIL] Incorrect value: " << valueB << " returned. *****" << std::endl;
+                rc = fail;
+                break;
+            }
+
+            // Print largeLeft.C
+            std::cerr << " C " << *(float *) ((char *) data + offset);
+            offset += sizeof(float);
+
+            // Print largeLeft.D
+            std::cerr << " D " << *(int *) ((char *) data + offset);
+            offset += sizeof(int);
+
+            // Print left.A
+            std::cerr << " left.A " << *(int *) ((char *) data + offset);
+            offset += sizeof(int);
+
+            // Print largeLeft.B
+            std::cerr << " B " << *(int *) ((char *) data + offset);
+            offset += sizeof(int);
+
+            // Print largeLeft.C
+            std::cerr << " C " << *(float *) ((char *) data + offset) << std::endl;
+        }
+
+        memset(data, 0, bufSize);
+        ++actualResultCnt;
+    }
+
+    if (expectedResultCnt != actualResultCnt) {
+        std::cerr << " ***** Expected Result Count: " << expectedResultCnt << std::endl;
+        std::cerr << " ***** [FAIL] The number of result: " << actualResultCnt << " is not correct. ***** "
+                  << std::endl;
+        rc = fail;
+    }
+
+    delete bnlJoin;
+    delete childBNLJoin;
+    delete leftIn;
+    delete rightIn1;
+    delete rightIn2;
+    free(data);
+    return rc;
+}
+
+int main() {
+
+    if (privateTestCase_5() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 5 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Private Test Case 5 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_p06.cc b/qe/qetest_p06.cc
new file mode 100755
index 0000000..4b6f646
--- /dev/null
+++ b/qe/qetest_p06.cc
@@ -0,0 +1,129 @@
+#include "qe_test_util.h"
+
+RC privateTestCase_6() {
+    RC rc = success;
+    // Functions Tested
+    // Left deep join using Index Nested Loop Join
+    std::cerr << std::endl << "***** In QE Private Test Case 6 *****" << std::endl;
+
+    // Prepare the iterator and condition
+    auto *leftIn = new TableScan(rm, "largeleft2");
+    auto *rightIn1 = new IndexScan(rm, "largeright2", "B");
+    auto *rightIn2 = new IndexScan(rm, "left", "B");
+
+    // Set up condition
+    Condition filterCond;
+    filterCond.lhsAttr = "largeleft2.B";
+    filterCond.op = LE_OP;
+    filterCond.bRhsIsAttr = false;
+    Value value1{};
+    value1.type = TypeInt;
+    value1.data = malloc(bufSize);
+    *(int *) value1.data = 109;
+    filterCond.rhsValue = value1;
+
+    // Create Filter
+    auto *filter = new Filter(leftIn, filterCond);
+
+    Condition joinCond1;
+    joinCond1.lhsAttr = "largeleft2.B";
+    joinCond1.op = EQ_OP;
+    joinCond1.bRhsIsAttr = true;
+    joinCond1.rhsAttr = "largeright2.B";
+
+    // Create child NLJoin
+    auto *childINLJoin = new INLJoin(filter, rightIn1, joinCond1);
+
+    Condition joinCond2;
+    joinCond2.lhsAttr = "largeleft2.B";
+    joinCond2.op = EQ_OP;
+    joinCond2.bRhsIsAttr = true;
+    joinCond2.rhsAttr = "left.B";
+
+    // Create top NLJoin
+    auto *inlJoin = new INLJoin(childINLJoin, rightIn2, joinCond2);
+
+    int expectedResultCnt = 90; //20~109 --> largeleft2.B: [10,109], largeright2.B: [20,50019], left.B: [10, 109]
+    int actualResultCnt = 0;
+    int valueB = 0;
+
+    // Go over the data through iterator
+    void *data = malloc(bufSize);
+    while (inlJoin->getNextTuple(data) != QE_EOF) {
+        if (actualResultCnt % 10 == 0) {
+
+            int offset = 2; //including nulls-indicator
+
+            // Print largeLeft.A
+            std::cerr << "largeleft2.A " << *(int *) ((char *) data + offset);
+            offset += sizeof(int);
+
+            // Print largeLeft.B
+            std::cerr << " B " << *(int *) ((char *) data + offset);
+            offset += sizeof(int);
+
+            // Print largeLeft.C
+            std::cerr << " C " << *(float *) ((char *) data + offset);
+            offset += sizeof(float);
+
+            // Print largeLeft.B
+            valueB = *(int *) ((char *) data + offset);
+            std::cerr << " largeright2.B " << valueB;
+            offset += sizeof(int);
+
+            if (valueB < 20 || valueB > 109) {
+                std::cerr << std::endl << "***** [FAIL] Incorrect value: " << valueB << " returned. *****" << std::endl;
+                rc = fail;
+                break;
+            }
+
+            // Print largeLeft.C
+            std::cerr << " C " << *(float *) ((char *) data + offset);
+            offset += sizeof(float);
+
+            // Print largeLeft.D
+            std::cerr << " D " << *(int *) ((char *) data + offset);
+            offset += sizeof(int);
+
+            // Print left.A
+            std::cerr << " left.A " << *(int *) ((char *) data + offset);
+            offset += sizeof(int);
+
+            // Print largeLeft.B
+            std::cerr << " B " << *(int *) ((char *) data + offset);
+            offset += sizeof(int);
+
+            // Print largeLeft.C
+            std::cerr << " C " << *(float *) ((char *) data + offset) << std::endl;
+        }
+
+        memset(data, 0, bufSize);
+        ++actualResultCnt;
+    }
+
+    if (expectedResultCnt != actualResultCnt) {
+        std::cerr << " ***** Expected Result Count: " << expectedResultCnt << std::endl;
+        std::cerr << " ***** [FAIL] The number of result: " << actualResultCnt << " is not correct. ***** "
+                  << std::endl;
+        rc = fail;
+    }
+
+    delete inlJoin;
+    delete childINLJoin;
+    delete leftIn;
+    delete rightIn1;
+    delete rightIn2;
+    free(data);
+    return rc;
+}
+
+int main() {
+
+    if (privateTestCase_6() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 6 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Private Test Case 6 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_p07.cc b/qe/qetest_p07.cc
new file mode 100755
index 0000000..42bab93
--- /dev/null
+++ b/qe/qetest_p07.cc
@@ -0,0 +1,137 @@
+#include "qe_test_util.h"
+
+RC privateTestCase_7() {
+    // Optional for all
+    // (+10 extra credit points will be given based on the results of the GHJ related tests)
+    // 1. GHJoin -- on Varchar Attribute
+    std::cerr << std::endl << "***** In QE Test Private Test Case 7 *****" << std::endl;
+
+    RC rc = success;
+
+    // Prepare the iterator and condition
+    auto *leftIn = new TableScan(rm, "leftvarchar");
+    auto *rightIn = new TableScan(rm, "rightvarchar");
+
+    // Set up condition
+    Condition filterCond;
+    filterCond.lhsAttr = "leftvarchar.A";
+    filterCond.op = LE_OP;
+    filterCond.bRhsIsAttr = false;
+    Value value1{};
+    value1.type = TypeInt;
+    value1.data = malloc(bufSize);
+    *(int *) value1.data = 45; // A[20-45], then B: a ... zzzzzzzzzzzzzzzzzzzzzzzzzz
+    filterCond.rhsValue = value1;
+
+    // Create Filter
+    auto *filter = new Filter(leftIn, filterCond);
+
+    // Set up condition
+    Condition filterCond2;
+    filterCond2.lhsAttr = "rightvarchar.C";
+    filterCond2.op = LE_OP;
+    filterCond2.bRhsIsAttr = false;
+    Value value2{};
+    value2.type = TypeReal;
+    value2.data = malloc(bufSize);
+    *(float *) value2.data = 35.0; // C[10.0-35.0], then B: a ... zzzzzzzzzzzzzzzzzzzzzzzzzz
+    filterCond2.rhsValue = value2;
+
+    // Create Filter
+    auto *filter2 = new Filter(rightIn, filterCond2);
+
+    Condition cond;
+    cond.lhsAttr = "leftvarchar.B";
+    cond.op = EQ_OP;
+    cond.bRhsIsAttr = true;
+    cond.rhsAttr = "rightvarchar.B";
+
+    int expectedResultCnt = 26;
+    int actualResultCnt = 0;
+    int numPartitons = 5;
+
+    // Create GHJoin
+    auto *ghJoin = new GHJoin(filter, filter2, cond, numPartitons);
+
+    // Go over the data through iterator
+    void *data = malloc(bufSize);
+    bool nullBit;
+
+    while (ghJoin->getNextTuple(data) != QE_EOF) {
+
+        // At this point, partitions should be on disk.
+
+        std::cerr << (actualResultCnt + 1) << " / " << expectedResultCnt << " tuples: ";
+        int offset = 0;
+        // is an attribute leftvarchar.A NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 7);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            rc = fail;
+            break;
+        }
+
+        // Print left.A
+        std::cerr << "leftvarchar.A " << *(int *) ((char *) data + offset + 1);
+        offset += sizeof(int);
+
+        // is an attribute left.B NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 6);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            rc = fail;
+            break;
+        }
+        // Print left.B
+        int length = *(int *) ((char *) data + offset + 1);
+        offset += 4;
+
+        char *b = (char *) malloc(100);
+        memcpy(b, (char *) data + offset + 1, length);
+        b[length] = '\0';
+        offset += length;
+        std::cerr << " B " << b;
+
+        // is an attribute right.C NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 4);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            rc = fail;
+            break;
+        }
+
+        // skip rightvarchar.B
+        offset = offset + 4 + length;
+
+        // Print right.C
+        std::cerr << "  rightvarchar.C " << *(float *) ((char *) data + offset + 1) << std::endl;
+
+        memset(data, 0, bufSize);
+        actualResultCnt++;
+
+    }
+
+    if (expectedResultCnt != actualResultCnt) {
+        std::cerr << "***** The number of returned tuple: " << actualResultCnt << " is not correct. *****" << std::endl;
+        rc = fail;
+    }
+
+    delete ghJoin;
+    delete filter;
+    delete filter2;
+    delete leftIn;
+    delete rightIn;
+    free(data);
+    return rc;
+}
+
+int main() {
+
+    if (privateTestCase_7() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 7 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Private Test Case 7 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_p08.cc b/qe/qetest_p08.cc
new file mode 100755
index 0000000..46d7d09
--- /dev/null
+++ b/qe/qetest_p08.cc
@@ -0,0 +1,161 @@
+#include "qe_test_util.h"
+
+RC privateTestCase_8() {
+    // Optional for all
+    // (+10 extra credit points will be given based on the results of the GHJ related tests)
+    // 1. GHJoin -- on Varchar Attribute
+    // 2. GHJoin -- on INT Attribute
+    std::cerr << std::endl << "***** In QE Test Private Test Case 8 *****" << std::endl;
+
+    RC rc = success;
+
+    // Prepare the iterator and condition
+    auto *leftIn = new TableScan(rm, "leftvarchar");
+    auto *rightIn = new TableScan(rm, "rightvarchar");
+    auto *anotherRightIn = new TableScan(rm, "left");
+
+    // Set up condition
+    Condition filterCond;
+    filterCond.lhsAttr = "leftvarchar.A";
+    filterCond.op = LE_OP;
+    filterCond.bRhsIsAttr = false;
+    Value value1{};
+    value1.type = TypeInt;
+    value1.data = malloc(bufSize);
+    *(int *) value1.data = 45; // A[20-45], then B: a ... zzzzzzzzzzzzzzzzzzzzzzzzzz
+    filterCond.rhsValue = value1;
+
+    // Create Filter
+    auto *filter = new Filter(leftIn, filterCond);
+
+    // Set up condition
+    Condition filterCond2;
+    filterCond2.lhsAttr = "rightvarchar.C";
+    filterCond2.op = LE_OP;
+    filterCond2.bRhsIsAttr = false;
+    Value value2{};
+    value2.type = TypeReal;
+    value2.data = malloc(bufSize);
+    *(float *) value2.data = 35.0; // C[10.0-35.0], then B: a ... zzzzzzzzzzzzzzzzzzzzzzzzzz
+    filterCond2.rhsValue = value2;
+
+    // Create Filter
+    auto *filter2 = new Filter(rightIn, filterCond2);
+
+    Condition cond;
+    cond.lhsAttr = "leftvarchar.B";
+    cond.op = EQ_OP;
+    cond.bRhsIsAttr = true;
+    cond.rhsAttr = "rightvarchar.B";
+
+    Condition cond2;
+    cond2.lhsAttr = "leftvarchar.A"; // [20 - 45]
+    cond2.op = EQ_OP;
+    cond2.bRhsIsAttr = true;
+    cond2.rhsAttr = "left.A"; // [0 - 99]
+
+    int expectedResultCnt = 26;
+    int actualResultCnt = 0;
+    int numPartitons = 5;
+
+    // Create GHJoin
+    auto *ghJoin = new GHJoin(filter, filter2, cond, numPartitons);
+
+    auto *ghJoin2 = new GHJoin(ghJoin, anotherRightIn, cond2, numPartitons);
+
+    // Go over the data through iterator
+    void *data = malloc(bufSize);
+    bool nullBit;
+
+    while (ghJoin2->getNextTuple(data) != QE_EOF) {
+
+        // At this point, partitions should be on disk.
+
+        std::cerr << (actualResultCnt + 1) << " / " << expectedResultCnt << " tuples: ";
+        int offset = 0;
+        // is an attribute leftvarchar.A NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 7);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            rc = fail;
+            break;
+        }
+        // Print left.A
+        int leftVarcharA = *(int *) ((char *) data + offset + 1);
+        std::cerr << "leftvarchar.A " << leftVarcharA;
+        offset += sizeof(int);
+
+        // is an attribute left.B NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 6);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            rc = fail;
+            break;
+        }
+        // Print left.B
+        int length = *(int *) ((char *) data + offset + 1);
+        offset += 4;
+
+        char *b = (char *) malloc(100);
+        memcpy(b, (char *) data + offset + 1, length);
+        b[length] = '\0';
+        offset += length;
+        std::cerr << " B " << b;
+
+        // is an attribute right.C NULL?
+        nullBit = *(unsigned char *) ((char *) data) & ((unsigned) 1 << (unsigned) 4);
+        if (nullBit) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            rc = fail;
+            break;
+        }
+
+        // skip rightvarchar.B
+        offset = offset + 4 + length;
+
+        // Print right.C
+        std::cerr << "  rightvarchar.C " << *(float *) ((char *) data + offset + 1) << std::endl;
+        offset += sizeof(float);
+
+        // left.A
+        int la = *(int *) ((char *) data + offset + 1);
+        offset += sizeof(int);
+
+        // left.B
+        int lb = *(int *) ((char *) data + offset + 1);
+        if (la != leftVarcharA || lb != (leftVarcharA + 10)) {
+            std::cerr << std::endl << "***** A returned value is not correct. *****" << std::endl;
+            rc = fail;
+            break;
+        }
+
+        memset(data, 0, bufSize);
+        actualResultCnt++;
+    }
+
+    if (expectedResultCnt != actualResultCnt) {
+        std::cerr << "***** The number of returned tuple: " << actualResultCnt << " is not correct. *****" << std::endl;
+        rc = fail;
+    }
+
+    delete ghJoin;
+    delete ghJoin2;
+    delete filter;
+    delete filter2;
+    delete leftIn;
+    delete rightIn;
+    delete anotherRightIn;
+    free(data);
+    return rc;
+}
+
+int main() {
+
+    if (privateTestCase_8() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 8 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Private Test Case 8 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_p09.cc b/qe/qetest_p09.cc
new file mode 100755
index 0000000..d43236f
--- /dev/null
+++ b/qe/qetest_p09.cc
@@ -0,0 +1,79 @@
+#include "qe_test_util.h"
+
+RC privateTestCase_9() {
+    // Mandatory for the grad teams/solos
+    // Optional for the undergrad solo
+    // (+5 extra credit points will be given based on the results of the basic aggregation related tests)
+    // 1. Basic aggregation - MIN
+    // SELECT MIN(largeleft.B) from largeleft
+    std::cerr << std::endl << "***** In QE Private Test Case 9 *****" << std::endl;
+
+    RC rc = success;
+
+    int compVal = 1000;
+
+    // Create IndexScan
+    auto *input = new TableScan(rm, "largeleft");
+
+    // Set up condition
+    Condition cond2;
+    cond2.lhsAttr = "largeleft.B";
+    cond2.op = LT_OP;
+    cond2.bRhsIsAttr = false;
+    Value value2{};
+    value2.type = TypeInt;
+    value2.data = malloc(bufSize);
+    *(int *) value2.data = compVal;
+    cond2.rhsValue = value2;
+
+    // Create Filter
+    auto *filter = new Filter(input, cond2);
+
+    // Create Aggregate
+    Attribute aggAttr;
+    aggAttr.name = "largeleft.B";
+    aggAttr.type = TypeInt;
+    aggAttr.length = 4;
+    auto *agg = new Aggregate(filter, aggAttr, MIN);
+
+    int count = 0;
+    void *data = malloc(bufSize);
+
+    // An aggregation returns a float value
+    float minVal = 0.0;
+
+    while (agg->getNextTuple(data) != QE_EOF) {
+        minVal = *(float *) ((char *) data + 1);
+        std::cerr << "MIN(largeleft.B) " << minVal << std::endl;
+        memset(data, 0, sizeof(int));
+        count++;
+        if (count > 1) {
+            std::cerr << "***** The number of returned tuple is not correct. *****" << std::endl;
+            rc = fail;
+            break;
+        }
+    }
+
+    if (minVal != 10.0) {
+        std::cerr << "***** The returned value: " << minVal << " is not correct. *****" << std::endl;
+        rc = fail;
+    }
+
+    delete agg;
+    delete filter;
+    delete input;
+    free(data);
+    return rc;
+
+}
+
+int main() {
+
+    if (privateTestCase_9() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 9 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Private Test Case 9 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_p10.cc b/qe/qetest_p10.cc
new file mode 100755
index 0000000..ede8838
--- /dev/null
+++ b/qe/qetest_p10.cc
@@ -0,0 +1,79 @@
+#include "qe_test_util.h"
+
+RC privateTestCase_10() {
+    // Mandatory for the grad teams/solos
+    // Optional for the undergrad solos
+    // (+5 extra credit points will be given based on the results of the basic aggregation related tests)
+    // 1. Basic aggregation - COUNT
+    // SELECT COUNT(largeleft.B) from largeleft
+    std::cerr << std::endl << "***** In QE Private Test Case 10 *****" << std::endl;
+
+    RC rc = success;
+
+    int compVal = 1000;
+
+    // Create IndexScan
+    auto *input = new TableScan(rm, "largeleft");
+
+    // Set up condition
+    Condition cond2;
+    cond2.lhsAttr = "largeleft.B";
+    cond2.op = LT_OP;
+    cond2.bRhsIsAttr = false;
+    Value value2{};
+    value2.type = TypeInt;
+    value2.data = malloc(bufSize);
+    *(int *) value2.data = compVal;
+    cond2.rhsValue = value2;
+
+    // Create Filter
+    auto *filter = new Filter(input, cond2);
+
+    // Create Aggregate
+    Attribute aggAttr;
+    aggAttr.name = "largeleft.B";
+    aggAttr.type = TypeInt;
+    aggAttr.length = 4;
+    auto *agg = new Aggregate(filter, aggAttr, COUNT);
+
+    int count = 0;
+    void *data = malloc(bufSize);
+
+    // An aggregation returns a float value
+    float countVal = 0.0;
+
+    while (agg->getNextTuple(data) != QE_EOF) {
+        countVal = *(float *) ((char *) data + 1);
+        std::cerr << "COUNT(largeleft.B) " << countVal << std::endl;
+        memset(data, 0, sizeof(int));
+        count++;
+        if (count > 1) {
+            std::cerr << "***** The number of returned tuple is not correct. *****" << std::endl;
+            rc = fail;
+            break;
+        }
+    }
+
+    if (countVal != 990.0) {
+        std::cerr << "***** The returned value: " << countVal << " is not correct. *****" << std::endl;
+        rc = fail;
+    }
+
+    delete agg;
+    delete filter;
+    delete input;
+    free(data);
+    return rc;
+
+}
+
+int main() {
+
+    if (privateTestCase_10() != success) {
+        std::cerr << "***** [FAIL] QE Test Case 10 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Private Test Case 10 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_p11.cc b/qe/qetest_p11.cc
new file mode 100755
index 0000000..0f9d09d
--- /dev/null
+++ b/qe/qetest_p11.cc
@@ -0,0 +1,99 @@
+#include "qe_test_util.h"
+
+RC privateTestCase_11() {
+    // Optional for all
+    // (+5 extra credit points will be given based on the results of the group-based hash aggregation related tests)
+    // Aggregate -- MAX (with GroupBy)
+    // SELECT group.B, MAX(group.C) FROM group where group.B > 3 GROUP BY group.B
+
+    std::cout << std::endl << "***** In QE Private Test Case 11 *****" << std::endl;
+
+    RC rc = 0;
+
+    // Create IndexScan
+    auto *input = new IndexScan(rm, "group", "B");
+
+    int compVal = 3; // group.B should be 4,5
+
+    // Set up condition
+    Condition cond2;
+    cond2.lhsAttr = "group.B";
+    cond2.op = GT_OP;
+    cond2.bRhsIsAttr = false;
+    Value value2{};
+    value2.type = TypeInt;
+    value2.data = malloc(bufSize);
+    *(int *) value2.data = compVal;
+    cond2.rhsValue = value2;
+
+    // Create Filter
+    auto *filter = new Filter(input, cond2);
+
+    // Create Aggregate
+    Attribute aggAttr;
+    aggAttr.name = "group.C";
+    aggAttr.type = TypeReal;
+    aggAttr.length = 4;
+
+    Attribute gAttr;
+    gAttr.name = "group.B";
+    gAttr.type = TypeInt;
+    gAttr.length = 4;
+    auto *agg = new Aggregate(filter, aggAttr, gAttr, MAX);
+
+    int idVal = 0;
+    float maxVal = 0;
+    int expectedResultCnt = 2;
+    int actualResultCnt = 0;
+
+    void *data = malloc(bufSize);
+
+    while (agg->getNextTuple(data) != QE_EOF) {
+        int offset = 0;
+
+        // Print group.B
+        idVal = *(int *) ((char *) data + offset + 1);
+        std::cout << "group.B " << idVal;
+        offset += sizeof(int);
+
+        // Print MAX(group.A)
+        maxVal = *(float *) ((char *) data + offset + 1);
+        std::cout << "  MAX(group.C) " << maxVal << std::endl;
+
+        memset(data, 0, bufSize);
+        if ((idVal == 4 && maxVal != 148) || (idVal == 5 && maxVal != 149)) {
+            std::cout << "***** The group-based aggregation is not working properly. *****" << std::endl;
+            rc = fail;
+            break;
+        }
+        actualResultCnt++;
+    }
+
+    if (expectedResultCnt != actualResultCnt) {
+        std::cout << "***** The number of returned tuple: " << actualResultCnt << " is not correct. *****" << std::endl;
+        rc = fail;
+    }
+
+    delete agg;
+    delete filter;
+    delete input;
+    free(data);
+    return rc;
+}
+
+int main() {
+    // Indexes created: group.B
+
+    if (createIndexforGroupB() != success) {
+        std::cout << "***** [FAIL] QE Private Test Case 11 failed. *****" << std::endl;
+        return fail;
+    }
+
+    if (privateTestCase_11() != success) {
+        std::cout << "***** [FAIL] QE Private Test Case 11 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cout << "***** QE Private Test Case 11 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/qe/qetest_p12.cc b/qe/qetest_p12.cc
new file mode 100755
index 0000000..7ef96da
--- /dev/null
+++ b/qe/qetest_p12.cc
@@ -0,0 +1,93 @@
+#include "qe_test_util.h"
+
+RC privateTestCase_12() {
+    // Optional for all teams - grad team, grad solo, undergrad team, and undergrad solo
+    // (+5 extra credit points will be given based on the results of the group-based hash aggregation related tests)
+    // Aggregate -- COUNT (with GroupBy)
+    // SELECT group.B, COUNT(group.A) FROM group where group.B < 5 GROUP BY group.B
+
+    std::cerr << std::endl << "***** In QE Private Test Case 12 *****" << std::endl;
+
+    RC rc = 0;
+
+    // Create IndexScan
+    auto *input = new IndexScan(rm, "group", "B");
+
+    int compVal = 5; // group.B should be 1,2,3,4
+
+    // Set up condition
+    Condition cond2;
+    cond2.lhsAttr = "group.B";
+    cond2.op = LT_OP;
+    cond2.bRhsIsAttr = false;
+    Value value2{};
+    value2.type = TypeInt;
+    value2.data = malloc(bufSize);
+    *(int *) value2.data = compVal;
+    cond2.rhsValue = value2;
+
+    // Create Filter
+    auto *filter = new Filter(input, cond2);
+
+    // Create Aggregate
+    Attribute aggAttr;
+    aggAttr.name = "group.A";
+    aggAttr.type = TypeInt;
+    aggAttr.length = 4;
+
+    Attribute gAttr;
+    gAttr.name = "group.B";
+    gAttr.type = TypeInt;
+    gAttr.length = 4;
+    auto *agg = new Aggregate(filter, aggAttr, gAttr, COUNT);
+
+    int idVal = 0;
+    float countVal = 0;
+    int expectedResultCnt = 4;
+    int actualResultCnt = 0;
+
+    void *data = malloc(bufSize);
+
+    while (agg->getNextTuple(data) != QE_EOF) {
+        int offset = 0;
+
+        // Print group.B
+        idVal = *(int *) ((char *) data + offset + 1);
+        std::cerr << "group.B " << idVal;
+        offset += sizeof(int);
+
+        // Print COUNT(group.A)
+        countVal = *(float *) ((char *) data + offset + 1);
+        std::cerr << "  COUNT(group.A) " << countVal << std::endl;
+
+        memset(data, 0, bufSize);
+//         if (countVal != 4) {
+//             std::cerr << "***** The group-based aggregation is not working properly. *****" << std::endl;
+//         	rc = fail;
+//         	goto clean_up;
+//         }
+        actualResultCnt++;
+    }
+
+    if (expectedResultCnt != actualResultCnt) {
+        std::cerr << "***** The number of returned tuple: " << actualResultCnt << " is not correct. *****" << std::endl;
+        rc = fail;
+    }
+
+    delete agg;
+    delete filter;
+    delete input;
+    free(data);
+    return rc;
+}
+
+int main() {
+
+    if (privateTestCase_12() != success) {
+        std::cerr << "***** [FAIL] QE Private Test Case 12 failed. *****" << std::endl;
+        return fail;
+    } else {
+        std::cerr << "***** QE Private Test Case 12 finished. The result will be examined. *****" << std::endl;
+        return success;
+    }
+}
diff --git a/rm/makefile b/rm/makefile
index 148d881..6444acd 100644
--- a/rm/makefile
+++ b/rm/makefile
@@ -43,45 +43,47 @@ rmtest_pex1.o: rm.h rm_test_util.h
 rmtest_pex2.o: rm.h rm_test_util.h
 
 # binary dependencies
-rmtest_create_tables: rmtest_create_tables.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_delete_tables: rmtest_delete_tables.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_00: rmtest_00.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_01: rmtest_01.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_02: rmtest_02.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_03: rmtest_03.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_04: rmtest_04.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_05: rmtest_05.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_06: rmtest_06.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_07: rmtest_07.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_08: rmtest_08.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_09: rmtest_09.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_10: rmtest_10.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_11: rmtest_11.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_12: rmtest_12.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_13: rmtest_13.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_13b: rmtest_13b.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_14: rmtest_14.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_15: rmtest_15.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_extra_1: rmtest_extra_1.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_extra_2: rmtest_extra_2.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_p0: rmtest_p0.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_p1: rmtest_p1.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_p2: rmtest_p2.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_p3: rmtest_p3.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_p4: rmtest_p4.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_p5: rmtest_p5.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_p6: rmtest_p6.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_p7: rmtest_p7.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_p8: rmtest_p8.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_p9: rmtest_p9.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_pex1: rmtest_pex1.o librm.a $(CODEROOT)/rbf/librbf.a
-rmtest_pex2: rmtest_pex2.o librm.a $(CODEROOT)/rbf/librbf.a
+rmtest_create_tables: rmtest_create_tables.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_delete_tables: rmtest_delete_tables.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_00: rmtest_00.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_01: rmtest_01.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_02: rmtest_02.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_03: rmtest_03.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_04: rmtest_04.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_05: rmtest_05.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_06: rmtest_06.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_07: rmtest_07.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_08: rmtest_08.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_09: rmtest_09.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_10: rmtest_10.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_11: rmtest_11.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_12: rmtest_12.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_13: rmtest_13.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_13b: rmtest_13b.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_14: rmtest_14.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_15: rmtest_15.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_extra_1: rmtest_extra_1.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_extra_2: rmtest_extra_2.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_p0: rmtest_p0.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_p1: rmtest_p1.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_p2: rmtest_p2.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_p3: rmtest_p3.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_p4: rmtest_p4.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_p5: rmtest_p5.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_p6: rmtest_p6.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_p7: rmtest_p7.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_p8: rmtest_p8.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_p9: rmtest_p9.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_pex1: rmtest_pex1.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
+rmtest_pex2: rmtest_pex2.o librm.a $(CODEROOT)/ix/libix.a $(CODEROOT)/rbf/librbf.a
 
 # dependencies to compile used libraries
-.PHONY: $(CODEROOT)/rbf/librbf.a
+.PHONY: $(CODEROOT)/rbf/librbf.a $(CODEROOT)/ix/libix.a
 $(CODEROOT)/rbf/librbf.a:
 	$(MAKE) -C $(CODEROOT)/rbf librbf.a
 
+$(CODEROOT)/ix/libix.a:
+	$(MAKE) -C $(CODEROOT)/ix libix.a
 
 .PHONY: clean
 clean:
diff --git a/rm/rm.cc b/rm/rm.cc
index cc7aa80..1b44cc1 100755
--- a/rm/rm.cc
+++ b/rm/rm.cc
@@ -79,5 +79,22 @@ RC RelationManager::addAttribute(const std::string &tableName, const Attribute &
     return -1;
 }
 
+// QE IX related
+RC RelationManager::createIndex(const std::string &tableName, const std::string &attributeName) {
+    return -1;
+}
 
+RC RelationManager::destroyIndex(const std::string &tableName, const std::string &attributeName) {
+    return -1;
+}
+
+RC RelationManager::indexScan(const std::string &tableName,
+                              const std::string &attributeName,
+                              const void *lowKey,
+                              const void *highKey,
+                              bool lowKeyInclusive,
+                              bool highKeyInclusive,
+                              RM_IndexScanIterator &rm_IndexScanIterator) {
+    return -1;
+}
 
diff --git a/rm/rm.h b/rm/rm.h
index a2d00db..b975284 100755
--- a/rm/rm.h
+++ b/rm/rm.h
@@ -21,6 +21,17 @@ public:
     RC close() { return -1; };
 };
 
+// RM_IndexScanIterator is an iterator to go through index entries
+class RM_IndexScanIterator {
+public:
+    RM_IndexScanIterator() {};    // Constructor
+    ~RM_IndexScanIterator() {};    // Destructor
+
+    // "key" follows the same format as in IndexManager::insertEntry()
+    RC getNextEntry(RID &rid, void *key) { return RM_EOF; };    // Get next matching entry
+    RC close() { return -1; };                        // Terminate index scan
+};
+
 // Relation Manager
 class RelationManager {
 public:
@@ -59,11 +70,25 @@ public:
             const std::vector<std::string> &attributeNames, // a list of projected attributes
             RM_ScanIterator &rm_ScanIterator);
 
-// Extra credit work (10 points)
+    // Extra credit work (10 points)
     RC addAttribute(const std::string &tableName, const Attribute &attr);
 
     RC dropAttribute(const std::string &tableName, const std::string &attributeName);
 
+    // QE IX related
+    RC createIndex(const std::string &tableName, const std::string &attributeName);
+
+    RC destroyIndex(const std::string &tableName, const std::string &attributeName);
+
+    // indexScan returns an iterator to allow the caller to go through qualified entries in index
+    RC indexScan(const std::string &tableName,
+                 const std::string &attributeName,
+                 const void *lowKey,
+                 const void *highKey,
+                 bool lowKeyInclusive,
+                 bool highKeyInclusive,
+                 RM_IndexScanIterator &rm_IndexScanIterator);
+
 protected:
     RelationManager();                                                  // Prevent construction
     ~RelationManager();                                                 // Prevent unwanted destruction
-- 
2.21.0 (Apple Git-120)

